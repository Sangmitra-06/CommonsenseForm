{"ast":null,"code":"import _objectSpread from\"C:/Users/sangm/OneDrive - Brock University/CommonsenseForm/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useReducer,useEffect,useCallback,useRef,useState}from'react';import{loadQuestionsData}from'../utils/helpers.ts';import*as api from'../services/api.ts';// Timer constants - simplified\nimport{jsx as _jsx}from\"react/jsx-runtime\";const TIMER_UPDATE_INTERVAL=1000;// Update every second\nconst initialState={sessionId:null,userInfo:null,currentPosition:{categoryIndex:0,subcategoryIndex:0,topicIndex:0,questionIndex:0},responses:new Map(),progress:{currentCategory:0,currentSubcategory:0,currentTopic:0,currentQuestion:0,completedQuestions:0,totalQuestions:0,completedTopics:[],attentionChecksPassed:0,attentionChecksFailed:0},isLoading:false,error:null,questionsData:[],startTime:0,lastSaveTime:0,isCompleted:false,// Simplified timer state\nsurveyStartTime:0,surveyTimeElapsed:0,// Count up from 0\nsurveyExpired:false,// Keep this false always now\nshowTimeWarning:false,// Always false now\nshowTimeCritical:false,// Always false now\n// Attention check failure state\nattentionCheckFailed:false,// NEW: Timing state\ntiming:null};function formReducer(state,action){switch(action.type){case'SET_LOADING':return _objectSpread(_objectSpread({},state),{},{isLoading:action.payload});case'SET_ERROR':return _objectSpread(_objectSpread({},state),{},{error:action.payload});case'SET_SESSION_ID':return _objectSpread(_objectSpread({},state),{},{sessionId:action.payload});case'SET_USER_INFO':return _objectSpread(_objectSpread({},state),{},{userInfo:action.payload});case'SET_QUESTIONS_DATA':return _objectSpread(_objectSpread({},state),{},{questionsData:action.payload});case'SET_CURRENT_POSITION':return _objectSpread(_objectSpread({},state),{},{currentPosition:action.payload});case'ADD_RESPONSE':const newResponses=new Map(state.responses);newResponses.set(action.payload.questionId,action.payload);return _objectSpread(_objectSpread({},state),{},{responses:newResponses});case'UPDATE_PROGRESS':return _objectSpread(_objectSpread({},state),{},{progress:_objectSpread(_objectSpread({},state.progress),action.payload)});case'SET_RESPONSES':const responseMap=new Map();action.payload.forEach(response=>{responseMap.set(response.questionId,response);});return _objectSpread(_objectSpread({},state),{},{responses:responseMap});case'SET_START_TIME':return _objectSpread(_objectSpread({},state),{},{startTime:action.payload});case'SET_LAST_SAVE_TIME':return _objectSpread(_objectSpread({},state),{},{lastSaveTime:action.payload});case'SET_COMPLETED':return _objectSpread(_objectSpread({},state),{},{isCompleted:action.payload});case'RESET_FORM':return _objectSpread(_objectSpread({},initialState),{},{questionsData:state.questionsData});// Simplified timer cases\ncase'START_SURVEY_TIMER':return _objectSpread(_objectSpread({},state),{},{surveyStartTime:Date.now(),surveyTimeElapsed:0,showTimeWarning:false,showTimeCritical:false,surveyExpired:false});case'UPDATE_TIMER':return _objectSpread(_objectSpread({},state),{},{surveyTimeElapsed:action.payload.timeElapsed});// Attention check failure case\ncase'SET_ATTENTION_CHECK_FAILED':return _objectSpread(_objectSpread({},state),{},{attentionCheckFailed:action.payload});// NEW: Timing case\ncase'SET_TIMING':return _objectSpread(_objectSpread({},state),{},{timing:action.payload});default:return state;}}// Updated interface\nconst FormContext=/*#__PURE__*/createContext(undefined);export function FormProvider(_ref){let{children}=_ref;const[state,dispatch]=useReducer(formReducer,initialState);const hasLoadedQuestions=useRef(false);const isLoadingSession=useRef(false);const[timerInterval,setTimerInterval]=useState(null);const surveyStartTimeRef=useRef(0);// Load questions data only once\nuseEffect(()=>{if(hasLoadedQuestions.current)return;const loadData=async()=>{try{hasLoadedQuestions.current=true;dispatch({type:'SET_LOADING',payload:true});dispatch({type:'SET_ERROR',payload:null});console.log('FormContext: Loading questions data...');const data=await loadQuestionsData();console.log('FormContext: Questions loaded:',data.length,'categories');dispatch({type:'SET_QUESTIONS_DATA',payload:data});const totalQuestions=getTotalQuestions(data);console.log('FormContext: Total questions calculated:',totalQuestions);dispatch({type:'UPDATE_PROGRESS',payload:{totalQuestions}});}catch(error){console.error('FormContext: Error loading questions:',error);dispatch({type:'SET_ERROR',payload:'Failed to load questions data. Please refresh the page.'});hasLoadedQuestions.current=false;}finally{dispatch({type:'SET_LOADING',payload:false});}};loadData();},[]);// Calculate total questions\nconst getTotalQuestions=questionsData=>{return questionsData.reduce((total,category)=>{return total+category.subcategories.reduce((subTotal,subcategory)=>{return subTotal+subcategory.topics.reduce((topicTotal,topic)=>{return topicTotal+topic.questions.length;},0);},0);},0);};// Simplified start timer function - counts UP\nconst startSurveyTimer=useCallback(()=>{const startTime=Date.now();console.log('Starting survey timer at:',new Date(startTime).toISOString());dispatch({type:'START_SURVEY_TIMER'});surveyStartTimeRef.current=startTime;// Clear any existing timer\nif(timerInterval){clearInterval(timerInterval);}// Start new timer that counts UP\nconst interval=setInterval(()=>{const now=Date.now();const elapsed=now-surveyStartTimeRef.current;dispatch({type:'UPDATE_TIMER',payload:{timeElapsed:elapsed}});},TIMER_UPDATE_INTERVAL);setTimerInterval(interval);},[timerInterval]);// Simplified resume timer function\nconst resumeSurveyTimer=useCallback(startTime=>{console.log('Resuming survey timer from:',new Date(startTime).toISOString());surveyStartTimeRef.current=startTime;const now=Date.now();const elapsed=now-startTime;dispatch({type:'UPDATE_TIMER',payload:{timeElapsed:elapsed}});// Clear any existing timer\nif(timerInterval){clearInterval(timerInterval);}// Start timer continuing from where it left off\nconst interval=setInterval(()=>{const now=Date.now();const elapsed=now-surveyStartTimeRef.current;dispatch({type:'UPDATE_TIMER',payload:{timeElapsed:elapsed}});},TIMER_UPDATE_INTERVAL);setTimerInterval(interval);},[timerInterval]);// Clean up timer on unmount\nuseEffect(()=>{return()=>{if(timerInterval){clearInterval(timerInterval);}};},[timerInterval]);// Simple format time function (shows elapsed time)\nconst formatTimeElapsed=useCallback(milliseconds=>{const totalSeconds=Math.floor(milliseconds/1000);const minutes=Math.floor(totalSeconds/60);const seconds=totalSeconds%60;return\"\".concat(minutes,\":\").concat(seconds.toString().padStart(2,'0'));},[]);// Attention check failure function\nconst setAttentionCheckFailed=useCallback(failed=>{dispatch({type:'SET_ATTENTION_CHECK_FAILED',payload:failed});},[]);// NEW: Timing function\nconst setTiming=useCallback(timing=>{dispatch({type:'SET_TIMING',payload:timing});},[]);// Create user session - UPDATED to handle timing\nconst createUserSession=useCallback(async userInfo=>{try{dispatch({type:'SET_LOADING',payload:true});console.log('FormContext: Creating user session with:',userInfo);const response=await api.createUser(userInfo);dispatch({type:'SET_SESSION_ID',payload:response.sessionId});dispatch({type:'SET_USER_INFO',payload:userInfo});// NEW: Set timing if provided from server\nif(response.startTime){const serverStartTime=new Date(response.startTime);dispatch({type:'SET_TIMING',payload:{startedAt:serverStartTime,completedAt:null,totalTimeSeconds:null,totalTimeFormatted:null}});console.log('FormContext: Server timing initialized:',serverStartTime.toISOString());}const startTime=Date.now();dispatch({type:'SET_START_TIME',payload:startTime});// Store session ID and start time in localStorage\nlocalStorage.setItem('culturalSurveySessionId',response.sessionId);localStorage.setItem('culturalSurveyStartTime',startTime.toString());// Start the survey timer\nconsole.log('FormContext: Creating user session and starting timer');startSurveyTimer();console.log('FormContext: User session created successfully');}catch(error){var _error$response,_error$response$data;console.error('FormContext: Error creating user session:',error);const errorMessage=((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.error)||'Failed to create session';dispatch({type:'SET_ERROR',payload:errorMessage});throw error;}finally{dispatch({type:'SET_LOADING',payload:false});}},[startSurveyTimer]);// Rest of your existing functions remain the same...\nconst loadUserSession=useCallback(async sessionId=>{if(isLoadingSession.current)return;try{isLoadingSession.current=true;dispatch({type:'SET_LOADING',payload:true});console.log('FormContext: Loading user session...');const user=await api.getUser(sessionId);dispatch({type:'SET_SESSION_ID',payload:sessionId});dispatch({type:'SET_USER_INFO',payload:user.userInfo});dispatch({type:'SET_COMPLETED',payload:user.isCompleted});// NEW: Load timing data if available\nif(user.timing){dispatch({type:'SET_TIMING',payload:{startedAt:new Date(user.timing.startedAt),completedAt:user.timing.completedAt?new Date(user.timing.completedAt):null,totalTimeSeconds:user.timing.totalTimeSeconds,totalTimeFormatted:user.timing.totalTimeFormatted}});console.log('FormContext: Timing data loaded from user session');}// Load responses\nconsole.log('FormContext: Loading user responses...');const responses=await api.getUserResponses(sessionId);console.log('FormContext: Responses loaded:',responses.length);dispatch({type:'SET_RESPONSES',payload:responses});// Recalculate total questions from current data\nconst totalQuestions=getTotalQuestions(state.questionsData);const updatedProgress=_objectSpread(_objectSpread({},user.progress),{},{totalQuestions,completedQuestions:responses.length});dispatch({type:'UPDATE_PROGRESS',payload:updatedProgress});// Find the correct starting position\nconst nextPosition=findNextUnansweredQuestion(responses,state.questionsData);console.log('FormContext: Setting position to:',nextPosition);dispatch({type:'SET_CURRENT_POSITION',payload:nextPosition});// Resume timer if not completed\nif(!user.isCompleted){const savedStartTime=localStorage.getItem('culturalSurveyStartTime');if(savedStartTime){resumeSurveyTimer(parseInt(savedStartTime));}else{// If no start time found, start fresh timer\nlocalStorage.setItem('culturalSurveyStartTime',Date.now().toString());startSurveyTimer();}}}catch(error){dispatch({type:'SET_ERROR',payload:'Failed to load user session'});throw error;}finally{dispatch({type:'SET_LOADING',payload:false});isLoadingSession.current=false;}},[state.questionsData,resumeSurveyTimer,startSurveyTimer]);const findNextUnansweredQuestion=useCallback((responses,questionsData)=>{const answeredQuestions=new Set(responses.map(r=>r.questionId));for(let categoryIndex=0;categoryIndex<questionsData.length;categoryIndex++){const category=questionsData[categoryIndex];for(let subcategoryIndex=0;subcategoryIndex<category.subcategories.length;subcategoryIndex++){const subcategory=category.subcategories[subcategoryIndex];for(let topicIndex=0;topicIndex<subcategory.topics.length;topicIndex++){const topic=subcategory.topics[topicIndex];for(let questionIndex=0;questionIndex<topic.questions.length;questionIndex++){const questionId=\"\".concat(categoryIndex,\"-\").concat(subcategoryIndex,\"-\").concat(topicIndex,\"-\").concat(questionIndex);if(!answeredQuestions.has(questionId)){return{categoryIndex,subcategoryIndex,topicIndex,questionIndex};}}}}}if(questionsData.length>0){const lastCategory=questionsData[questionsData.length-1];const lastSubcategory=lastCategory.subcategories[lastCategory.subcategories.length-1];const lastTopic=lastSubcategory.topics[lastSubcategory.topics.length-1];return{categoryIndex:questionsData.length-1,subcategoryIndex:lastCategory.subcategories.length-1,topicIndex:lastSubcategory.topics.length-1,questionIndex:lastTopic.questions.length-1};}return{categoryIndex:0,subcategoryIndex:0,topicIndex:0,questionIndex:0};},[]);const saveResponse=useCallback(async response=>{try{console.log('FormContext: Saving response:',response);await api.saveResponse(response);dispatch({type:'ADD_RESPONSE',payload:response});dispatch({type:'SET_LAST_SAVE_TIME',payload:Date.now()});// Only count non-attention check responses for progress\nconst wasNewResponse=!state.responses.has(response.questionId);const isActualQuestion=!response.questionId.startsWith('ATTENTION_CHECK_');if(wasNewResponse&&isActualQuestion){const completedQuestions=Array.from(state.responses.keys()).filter(questionId=>!questionId.startsWith('ATTENTION_CHECK_')).length+1;// +1 for the response we just added\ndispatch({type:'UPDATE_PROGRESS',payload:{completedQuestions}});}}catch(error){console.error('FormContext: Error saving response:',error);dispatch({type:'SET_ERROR',payload:'Failed to save response'});throw error;}},[state.responses]);const navigateToPosition=useCallback(async(categoryIndex,subcategoryIndex,topicIndex,questionIndex)=>{const newPosition={categoryIndex,subcategoryIndex,topicIndex,questionIndex};dispatch({type:'SET_CURRENT_POSITION',payload:newPosition});if(state.sessionId){try{await api.updateUserProgress(state.sessionId,{currentCategory:categoryIndex,currentSubcategory:subcategoryIndex,currentTopic:topicIndex,currentQuestion:questionIndex});}catch(error){console.error('Failed to save navigation progress:',error);}}},[state.sessionId]);const getCurrentQuestionData=useCallback(()=>{const{categoryIndex,subcategoryIndex,topicIndex,questionIndex}=state.currentPosition;if(!state.questionsData[categoryIndex])return null;const category=state.questionsData[categoryIndex];const subcategory=category.subcategories[subcategoryIndex];const topic=subcategory===null||subcategory===void 0?void 0:subcategory.topics[topicIndex];const question=topic===null||topic===void 0?void 0:topic.questions[questionIndex];if(!question)return null;return{category:category.category,subcategory:subcategory.subcategory,topic:topic.topic,question,questionId:\"\".concat(categoryIndex,\"-\").concat(subcategoryIndex,\"-\").concat(topicIndex,\"-\").concat(questionIndex)};},[state.currentPosition,state.questionsData]);const getCurrentQuestion=useCallback(()=>{const data=getCurrentQuestionData();return(data===null||data===void 0?void 0:data.question)||null;},[getCurrentQuestionData]);const navigateToNext=useCallback(async()=>{const{categoryIndex,subcategoryIndex,topicIndex,questionIndex}=state.currentPosition;const category=state.questionsData[categoryIndex];if(!category)return;const subcategory=category.subcategories[subcategoryIndex];const topic=subcategory===null||subcategory===void 0?void 0:subcategory.topics[topicIndex];if(!topic)return;let newPosition=_objectSpread({},state.currentPosition);if(questionIndex<topic.questions.length-1){newPosition.questionIndex=questionIndex+1;}else if(topicIndex<subcategory.topics.length-1){newPosition.topicIndex=topicIndex+1;newPosition.questionIndex=0;}else if(subcategoryIndex<category.subcategories.length-1){newPosition.subcategoryIndex=subcategoryIndex+1;newPosition.topicIndex=0;newPosition.questionIndex=0;}else if(categoryIndex<state.questionsData.length-1){newPosition.categoryIndex=categoryIndex+1;newPosition.subcategoryIndex=0;newPosition.topicIndex=0;newPosition.questionIndex=0;}else{dispatch({type:'SET_COMPLETED',payload:true});return;}dispatch({type:'SET_CURRENT_POSITION',payload:newPosition});if(state.sessionId){try{await api.updateUserProgress(state.sessionId,{currentCategory:newPosition.categoryIndex,currentSubcategory:newPosition.subcategoryIndex,currentTopic:newPosition.topicIndex,currentQuestion:newPosition.questionIndex});}catch(error){console.error('Failed to save progress:',error);}}},[state.currentPosition,state.questionsData,state.sessionId]);const navigateToPrevious=useCallback(async()=>{const{categoryIndex,subcategoryIndex,topicIndex,questionIndex}=state.currentPosition;let newPosition=_objectSpread({},state.currentPosition);if(questionIndex>0){newPosition.questionIndex=questionIndex-1;}else if(topicIndex>0){const prevTopic=state.questionsData[categoryIndex].subcategories[subcategoryIndex].topics[topicIndex-1];newPosition.topicIndex=topicIndex-1;newPosition.questionIndex=prevTopic.questions.length-1;}else if(subcategoryIndex>0){const prevSubcategory=state.questionsData[categoryIndex].subcategories[subcategoryIndex-1];const lastTopic=prevSubcategory.topics[prevSubcategory.topics.length-1];newPosition.subcategoryIndex=subcategoryIndex-1;newPosition.topicIndex=prevSubcategory.topics.length-1;newPosition.questionIndex=lastTopic.questions.length-1;}else if(categoryIndex>0){const prevCategory=state.questionsData[categoryIndex-1];const lastSubcategory=prevCategory.subcategories[prevCategory.subcategories.length-1];const lastTopic=lastSubcategory.topics[lastSubcategory.topics.length-1];newPosition.categoryIndex=categoryIndex-1;newPosition.subcategoryIndex=prevCategory.subcategories.length-1;newPosition.topicIndex=lastSubcategory.topics.length-1;newPosition.questionIndex=lastTopic.questions.length-1;}dispatch({type:'SET_CURRENT_POSITION',payload:newPosition});if(state.sessionId){try{await api.updateUserProgress(state.sessionId,{currentCategory:newPosition.categoryIndex,currentSubcategory:newPosition.subcategoryIndex,currentTopic:newPosition.topicIndex,currentQuestion:newPosition.questionIndex});}catch(error){console.error('Failed to save progress:',error);}}},[state.currentPosition,state.questionsData,state.sessionId]);const calculateProgress=useCallback(()=>{const totalQuestions=state.progress.totalQuestions;// Filter out attention check responses from the count\nconst completedQuestions=Array.from(state.responses.keys()).filter(questionId=>!questionId.startsWith('ATTENTION_CHECK_')).length;return totalQuestions>0?completedQuestions/totalQuestions*100:0;},[state.progress.totalQuestions,state.responses]);const getTotalQuestionsInCurrentTopic=useCallback(()=>{var _state$questionsData$,_state$questionsData$2;const{categoryIndex,subcategoryIndex,topicIndex}=state.currentPosition;const topic=(_state$questionsData$=state.questionsData[categoryIndex])===null||_state$questionsData$===void 0?void 0:(_state$questionsData$2=_state$questionsData$.subcategories[subcategoryIndex])===null||_state$questionsData$2===void 0?void 0:_state$questionsData$2.topics[topicIndex];return(topic===null||topic===void 0?void 0:topic.questions.length)||0;},[state.currentPosition,state.questionsData]);const getCompletedQuestionsInCurrentTopic=useCallback(()=>{var _state$questionsData$3,_state$questionsData$4;const{categoryIndex,subcategoryIndex,topicIndex}=state.currentPosition;let completed=0;const topic=(_state$questionsData$3=state.questionsData[categoryIndex])===null||_state$questionsData$3===void 0?void 0:(_state$questionsData$4=_state$questionsData$3.subcategories[subcategoryIndex])===null||_state$questionsData$4===void 0?void 0:_state$questionsData$4.topics[topicIndex];if(!topic)return 0;topic.questions.forEach((_,questionIndex)=>{const questionId=\"\".concat(categoryIndex,\"-\").concat(subcategoryIndex,\"-\").concat(topicIndex,\"-\").concat(questionIndex);if(state.responses.has(questionId)){completed++;}});return completed;},[state.currentPosition,state.questionsData,state.responses]);// Reset session function\nconst resetSession=useCallback(()=>{localStorage.removeItem('culturalSurveySessionId');localStorage.removeItem('culturalSurveyStartTime');if(timerInterval){clearInterval(timerInterval);setTimerInterval(null);}surveyStartTimeRef.current=0;dispatch({type:'RESET_FORM'});},[timerInterval]);const value={state,dispatch,createUserSession,saveResponse,navigateToNext,navigateToPrevious,calculateProgress,getCurrentQuestion,getCurrentQuestionData,getTotalQuestionsInCurrentTopic,getCompletedQuestionsInCurrentTopic,loadUserSession,navigateToPosition,resetSession,startSurveyTimer,resumeSurveyTimer,formatTimeElapsed,setAttentionCheckFailed,setTiming};return/*#__PURE__*/_jsx(FormContext.Provider,{value:value,children:children});}export function useForm(){const context=useContext(FormContext);if(context===undefined){throw new Error('useForm must be used within a FormProvider');}return context;}","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","useCallback","useRef","useState","loadQuestionsData","api","jsx","_jsx","TIMER_UPDATE_INTERVAL","initialState","sessionId","userInfo","currentPosition","categoryIndex","subcategoryIndex","topicIndex","questionIndex","responses","Map","progress","currentCategory","currentSubcategory","currentTopic","currentQuestion","completedQuestions","totalQuestions","completedTopics","attentionChecksPassed","attentionChecksFailed","isLoading","error","questionsData","startTime","lastSaveTime","isCompleted","surveyStartTime","surveyTimeElapsed","surveyExpired","showTimeWarning","showTimeCritical","attentionCheckFailed","timing","formReducer","state","action","type","_objectSpread","payload","newResponses","set","questionId","responseMap","forEach","response","Date","now","timeElapsed","FormContext","undefined","FormProvider","_ref","children","dispatch","hasLoadedQuestions","isLoadingSession","timerInterval","setTimerInterval","surveyStartTimeRef","current","loadData","console","log","data","length","getTotalQuestions","reduce","total","category","subcategories","subTotal","subcategory","topics","topicTotal","topic","questions","startSurveyTimer","toISOString","clearInterval","interval","setInterval","elapsed","resumeSurveyTimer","formatTimeElapsed","milliseconds","totalSeconds","Math","floor","minutes","seconds","concat","toString","padStart","setAttentionCheckFailed","failed","setTiming","createUserSession","createUser","serverStartTime","startedAt","completedAt","totalTimeSeconds","totalTimeFormatted","localStorage","setItem","_error$response","_error$response$data","errorMessage","loadUserSession","user","getUser","getUserResponses","updatedProgress","nextPosition","findNextUnansweredQuestion","savedStartTime","getItem","parseInt","answeredQuestions","Set","map","r","has","lastCategory","lastSubcategory","lastTopic","saveResponse","wasNewResponse","isActualQuestion","startsWith","Array","from","keys","filter","navigateToPosition","newPosition","updateUserProgress","getCurrentQuestionData","question","getCurrentQuestion","navigateToNext","navigateToPrevious","prevTopic","prevSubcategory","prevCategory","calculateProgress","getTotalQuestionsInCurrentTopic","_state$questionsData$","_state$questionsData$2","getCompletedQuestionsInCurrentTopic","_state$questionsData$3","_state$questionsData$4","completed","_","resetSession","removeItem","value","Provider","useForm","context","Error"],"sources":["C:/Users/sangm/OneDrive - Brock University/CommonsenseForm/client/src/context/FormContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, ReactNode, useCallback, useRef, useState } from 'react';\r\nimport { FormState, UserInfo, QuestionResponse, Category, Progress, SurveyTiming } from '../types/index.ts';\r\nimport { loadQuestionsData } from '../utils/helpers.ts';\r\nimport * as api from '../services/api.ts';\r\n\r\n// Timer constants - simplified\r\nconst TIMER_UPDATE_INTERVAL = 1000; // Update every second\r\n\r\ntype FormAction =\r\n  | { type: 'SET_LOADING'; payload: boolean }\r\n  | { type: 'SET_ERROR'; payload: string | null }\r\n  | { type: 'SET_SESSION_ID'; payload: string }\r\n  | { type: 'SET_USER_INFO'; payload: UserInfo }\r\n  | { type: 'SET_QUESTIONS_DATA'; payload: Category[] }\r\n  | { type: 'SET_CURRENT_POSITION'; payload: { categoryIndex: number; subcategoryIndex: number; topicIndex: number; questionIndex: number } }\r\n  | { type: 'ADD_RESPONSE'; payload: QuestionResponse }\r\n  | { type: 'UPDATE_PROGRESS'; payload: Partial<Progress> }\r\n  | { type: 'SET_RESPONSES'; payload: QuestionResponse[] }\r\n  | { type: 'SET_START_TIME'; payload: number }\r\n  | { type: 'SET_LAST_SAVE_TIME'; payload: number }\r\n  | { type: 'SET_COMPLETED'; payload: boolean }\r\n  | { type: 'RESET_FORM' }\r\n  // Simplified timer actions\r\n  | { type: 'START_SURVEY_TIMER' }\r\n  | { type: 'UPDATE_TIMER'; payload: { timeElapsed: number } }\r\n  // Attention check failure\r\n  | { type: 'SET_ATTENTION_CHECK_FAILED'; payload: boolean }\r\n  // NEW: Timing action\r\n  | { type: 'SET_TIMING'; payload: SurveyTiming | null };\r\n\r\nconst initialState: FormState = {\r\n  sessionId: null,\r\n  userInfo: null,\r\n  currentPosition: {\r\n    categoryIndex: 0,\r\n    subcategoryIndex: 0,\r\n    topicIndex: 0,\r\n    questionIndex: 0\r\n  },\r\n  responses: new Map(),\r\n  progress: {\r\n    currentCategory: 0,\r\n    currentSubcategory: 0,\r\n    currentTopic: 0,\r\n    currentQuestion: 0,\r\n    completedQuestions: 0,\r\n    totalQuestions: 0,\r\n    completedTopics: [],\r\n    attentionChecksPassed: 0,\r\n    attentionChecksFailed: 0\r\n  },\r\n  isLoading: false,\r\n  error: null,\r\n  questionsData: [],\r\n  startTime: 0,\r\n  lastSaveTime: 0,\r\n  isCompleted: false,\r\n  // Simplified timer state\r\n  surveyStartTime: 0,\r\n  surveyTimeElapsed: 0, // Count up from 0\r\n  surveyExpired: false, // Keep this false always now\r\n  showTimeWarning: false, // Always false now\r\n  showTimeCritical: false, // Always false now\r\n  // Attention check failure state\r\n  attentionCheckFailed: false,\r\n  // NEW: Timing state\r\n  timing: null,\r\n};\r\n\r\nfunction formReducer(state: FormState, action: FormAction): FormState {\r\n  switch (action.type) {\r\n    case 'SET_LOADING':\r\n      return { ...state, isLoading: action.payload };\r\n    case 'SET_ERROR':\r\n      return { ...state, error: action.payload };\r\n    case 'SET_SESSION_ID':\r\n      return { ...state, sessionId: action.payload };\r\n    case 'SET_USER_INFO':\r\n      return { ...state, userInfo: action.payload };\r\n    case 'SET_QUESTIONS_DATA':\r\n      return { ...state, questionsData: action.payload };\r\n    case 'SET_CURRENT_POSITION':\r\n      return { ...state, currentPosition: action.payload };\r\n    case 'ADD_RESPONSE':\r\n      const newResponses = new Map(state.responses);\r\n      newResponses.set(action.payload.questionId, action.payload);\r\n      return { ...state, responses: newResponses };\r\n    case 'UPDATE_PROGRESS':\r\n      return { \r\n        ...state, \r\n        progress: { ...state.progress, ...action.payload }\r\n      };\r\n    case 'SET_RESPONSES':\r\n      const responseMap = new Map();\r\n      action.payload.forEach(response => {\r\n        responseMap.set(response.questionId, response);\r\n      });\r\n      return { ...state, responses: responseMap };\r\n    case 'SET_START_TIME':\r\n      return { ...state, startTime: action.payload };\r\n    case 'SET_LAST_SAVE_TIME':\r\n      return { ...state, lastSaveTime: action.payload };\r\n    case 'SET_COMPLETED':\r\n      return { ...state, isCompleted: action.payload };\r\n    case 'RESET_FORM':\r\n      return { ...initialState, questionsData: state.questionsData };\r\n    // Simplified timer cases\r\n    case 'START_SURVEY_TIMER':\r\n      return {\r\n        ...state,\r\n        surveyStartTime: Date.now(),\r\n        surveyTimeElapsed: 0,\r\n        showTimeWarning: false,\r\n        showTimeCritical: false,\r\n        surveyExpired: false\r\n      };\r\n    case 'UPDATE_TIMER':\r\n      return {\r\n        ...state,\r\n        surveyTimeElapsed: action.payload.timeElapsed\r\n      };\r\n    // Attention check failure case\r\n    case 'SET_ATTENTION_CHECK_FAILED':\r\n      return {\r\n        ...state,\r\n        attentionCheckFailed: action.payload\r\n      };\r\n    // NEW: Timing case\r\n    case 'SET_TIMING':\r\n      return { ...state, timing: action.payload };\r\n    \r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Updated interface\r\ninterface FormContextType {\r\n  state: FormState;\r\n  dispatch: React.Dispatch<FormAction>;\r\n  createUserSession: (userInfo: UserInfo) => Promise<void>;\r\n  saveResponse: (response: QuestionResponse) => Promise<void>;\r\n  navigateToNext: () => void;\r\n  navigateToPrevious: () => void;\r\n  calculateProgress: () => number;\r\n  getCurrentQuestion: () => string | null;\r\n  getCurrentQuestionData: () => {\r\n    category: string;\r\n    subcategory: string;\r\n    topic: string;\r\n    question: string;\r\n    questionId: string;\r\n  } | null;\r\n  getTotalQuestionsInCurrentTopic: () => number;\r\n  getCompletedQuestionsInCurrentTopic: () => number;\r\n  loadUserSession: (sessionId: string) => Promise<void>;\r\n  navigateToPosition: (categoryIndex: number, subcategoryIndex: number, topicIndex: number, questionIndex: number) => Promise<void>;\r\n  resetSession: () => void;\r\n  // Simplified timer functions\r\n  startSurveyTimer: () => void;\r\n  resumeSurveyTimer: (startTime: number) => void;\r\n  formatTimeElapsed: (milliseconds: number) => string;\r\n  // Attention check failure function\r\n  setAttentionCheckFailed: (failed: boolean) => void;\r\n  // NEW: Timing function\r\n  setTiming: (timing: SurveyTiming | null) => void;\r\n}\r\n\r\nconst FormContext = createContext<FormContextType | undefined>(undefined);\r\n\r\nexport function FormProvider({ children }: { children: ReactNode }) {\r\n  const [state, dispatch] = useReducer(formReducer, initialState);\r\n  const hasLoadedQuestions = useRef(false);\r\n  const isLoadingSession = useRef(false);\r\n  const [timerInterval, setTimerInterval] = useState<ReturnType<typeof setInterval> | null>(null);\r\n  const surveyStartTimeRef = useRef<number>(0);\r\n\r\n  // Load questions data only once\r\n  useEffect(() => {\r\n    if (hasLoadedQuestions.current) return;\r\n    \r\n    const loadData = async () => {\r\n      try {\r\n        hasLoadedQuestions.current = true;\r\n        dispatch({ type: 'SET_LOADING', payload: true });\r\n        dispatch({ type: 'SET_ERROR', payload: null });\r\n        \r\n        console.log('FormContext: Loading questions data...');\r\n        const data = await loadQuestionsData();\r\n        console.log('FormContext: Questions loaded:', data.length, 'categories');\r\n        \r\n        dispatch({ type: 'SET_QUESTIONS_DATA', payload: data });\r\n        \r\n        const totalQuestions = getTotalQuestions(data);\r\n        console.log('FormContext: Total questions calculated:', totalQuestions);\r\n        \r\n        dispatch({ type: 'UPDATE_PROGRESS', payload: { totalQuestions } });\r\n        \r\n      } catch (error) {\r\n        console.error('FormContext: Error loading questions:', error);\r\n        dispatch({ type: 'SET_ERROR', payload: 'Failed to load questions data. Please refresh the page.' });\r\n        hasLoadedQuestions.current = false;\r\n      } finally {\r\n        dispatch({ type: 'SET_LOADING', payload: false });\r\n      }\r\n    };\r\n\r\n    loadData();\r\n  }, []);\r\n\r\n  // Calculate total questions\r\n  const getTotalQuestions = (questionsData: Category[]): number => {\r\n    return questionsData.reduce((total, category) => {\r\n      return total + category.subcategories.reduce((subTotal, subcategory) => {\r\n        return subTotal + subcategory.topics.reduce((topicTotal, topic) => {\r\n          return topicTotal + topic.questions.length;\r\n        }, 0);\r\n      }, 0);\r\n    }, 0);\r\n  };\r\n\r\n  // Simplified start timer function - counts UP\r\n  const startSurveyTimer = useCallback(() => {\r\n    const startTime = Date.now();\r\n    console.log('Starting survey timer at:', new Date(startTime).toISOString());\r\n    \r\n    dispatch({ type: 'START_SURVEY_TIMER' });\r\n    surveyStartTimeRef.current = startTime;\r\n    \r\n    // Clear any existing timer\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n    }\r\n\r\n    // Start new timer that counts UP\r\n    const interval = setInterval(() => {\r\n      const now = Date.now();\r\n      const elapsed = now - surveyStartTimeRef.current;\r\n      \r\n      dispatch({ \r\n        type: 'UPDATE_TIMER', \r\n        payload: { \r\n          timeElapsed: elapsed\r\n        } \r\n      });\r\n    }, TIMER_UPDATE_INTERVAL);\r\n\r\n    setTimerInterval(interval);\r\n  }, [timerInterval]);\r\n\r\n  // Simplified resume timer function\r\n  const resumeSurveyTimer = useCallback((startTime: number) => {\r\n    console.log('Resuming survey timer from:', new Date(startTime).toISOString());\r\n    \r\n    surveyStartTimeRef.current = startTime;\r\n    const now = Date.now();\r\n    const elapsed = now - startTime;\r\n\r\n    dispatch({\r\n      type: 'UPDATE_TIMER',\r\n      payload: {\r\n        timeElapsed: elapsed\r\n      }\r\n    });\r\n\r\n    // Clear any existing timer\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n    }\r\n\r\n    // Start timer continuing from where it left off\r\n    const interval = setInterval(() => {\r\n      const now = Date.now();\r\n      const elapsed = now - surveyStartTimeRef.current;\r\n      \r\n      dispatch({ \r\n        type: 'UPDATE_TIMER', \r\n        payload: { \r\n          timeElapsed: elapsed\r\n        } \r\n      });\r\n    }, TIMER_UPDATE_INTERVAL);\r\n\r\n    setTimerInterval(interval);\r\n  }, [timerInterval]);\r\n\r\n  // Clean up timer on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (timerInterval) {\r\n        clearInterval(timerInterval);\r\n      }\r\n    };\r\n  }, [timerInterval]);\r\n\r\n  // Simple format time function (shows elapsed time)\r\n  const formatTimeElapsed = useCallback((milliseconds: number): string => {\r\n    const totalSeconds = Math.floor(milliseconds / 1000);\r\n    const minutes = Math.floor(totalSeconds / 60);\r\n    const seconds = totalSeconds % 60;\r\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\r\n  }, []);\r\n\r\n  // Attention check failure function\r\n  const setAttentionCheckFailed = useCallback((failed: boolean) => {\r\n    dispatch({ type: 'SET_ATTENTION_CHECK_FAILED', payload: failed });\r\n  }, []);\r\n\r\n  // NEW: Timing function\r\n  const setTiming = useCallback((timing: SurveyTiming | null) => {\r\n    dispatch({ type: 'SET_TIMING', payload: timing });\r\n  }, []);\r\n\r\n  // Create user session - UPDATED to handle timing\r\n  const createUserSession = useCallback(async (userInfo: UserInfo) => {\r\n    try {\r\n      dispatch({ type: 'SET_LOADING', payload: true });\r\n      console.log('FormContext: Creating user session with:', userInfo);\r\n      \r\n      const response = await api.createUser(userInfo);\r\n      \r\n      dispatch({ type: 'SET_SESSION_ID', payload: response.sessionId });\r\n      dispatch({ type: 'SET_USER_INFO', payload: userInfo });\r\n      \r\n      // NEW: Set timing if provided from server\r\n      if (response.startTime) {\r\n        const serverStartTime = new Date(response.startTime);\r\n        dispatch({ type: 'SET_TIMING', payload: {\r\n          startedAt: serverStartTime,\r\n          completedAt: null,\r\n          totalTimeSeconds: null,\r\n          totalTimeFormatted: null\r\n        }});\r\n        console.log('FormContext: Server timing initialized:', serverStartTime.toISOString());\r\n      }\r\n      \r\n      const startTime = Date.now();\r\n      dispatch({ type: 'SET_START_TIME', payload: startTime });\r\n      \r\n      // Store session ID and start time in localStorage\r\n      localStorage.setItem('culturalSurveySessionId', response.sessionId);\r\n      localStorage.setItem('culturalSurveyStartTime', startTime.toString());\r\n      \r\n      // Start the survey timer\r\n      console.log('FormContext: Creating user session and starting timer');\r\n      startSurveyTimer();\r\n      \r\n      console.log('FormContext: User session created successfully');\r\n      \r\n    } catch (error: any) {\r\n      console.error('FormContext: Error creating user session:', error);\r\n      \r\n      const errorMessage = error.response?.data?.error || 'Failed to create session';\r\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\r\n      \r\n      throw error;\r\n    } finally {\r\n      dispatch({ type: 'SET_LOADING', payload: false });\r\n    }\r\n  }, [startSurveyTimer]);\r\n\r\n  // Rest of your existing functions remain the same...\r\n  const loadUserSession = useCallback(async (sessionId: string) => {\r\n    if (isLoadingSession.current) return;\r\n    \r\n    try {\r\n      isLoadingSession.current = true;\r\n      dispatch({ type: 'SET_LOADING', payload: true });\r\n      \r\n      console.log('FormContext: Loading user session...');\r\n      const user = await api.getUser(sessionId);\r\n      \r\n      dispatch({ type: 'SET_SESSION_ID', payload: sessionId });\r\n      dispatch({ type: 'SET_USER_INFO', payload: user.userInfo });\r\n      dispatch({ type: 'SET_COMPLETED', payload: user.isCompleted });\r\n      \r\n      // NEW: Load timing data if available\r\n      if (user.timing) {\r\n        dispatch({ type: 'SET_TIMING', payload: {\r\n          startedAt: new Date(user.timing.startedAt),\r\n          completedAt: user.timing.completedAt ? new Date(user.timing.completedAt) : null,\r\n          totalTimeSeconds: user.timing.totalTimeSeconds,\r\n          totalTimeFormatted: user.timing.totalTimeFormatted\r\n        }});\r\n        console.log('FormContext: Timing data loaded from user session');\r\n      }\r\n      \r\n      // Load responses\r\n      console.log('FormContext: Loading user responses...');\r\n      const responses = await api.getUserResponses(sessionId);\r\n      console.log('FormContext: Responses loaded:', responses.length);\r\n      \r\n      dispatch({ type: 'SET_RESPONSES', payload: responses });\r\n      \r\n      // Recalculate total questions from current data\r\n      const totalQuestions = getTotalQuestions(state.questionsData);\r\n      \r\n      const updatedProgress = {\r\n        ...user.progress,\r\n        totalQuestions,\r\n        completedQuestions: responses.length\r\n      };\r\n      \r\n      dispatch({ type: 'UPDATE_PROGRESS', payload: updatedProgress });\r\n      \r\n      // Find the correct starting position\r\n      const nextPosition = findNextUnansweredQuestion(responses, state.questionsData);\r\n      console.log('FormContext: Setting position to:', nextPosition);\r\n      \r\n      dispatch({ type: 'SET_CURRENT_POSITION', payload: nextPosition });\r\n      \r\n      // Resume timer if not completed\r\n      if (!user.isCompleted) {\r\n        const savedStartTime = localStorage.getItem('culturalSurveyStartTime');\r\n        if (savedStartTime) {\r\n          resumeSurveyTimer(parseInt(savedStartTime));\r\n        } else {\r\n          // If no start time found, start fresh timer\r\n          localStorage.setItem('culturalSurveyStartTime', Date.now().toString());\r\n          startSurveyTimer();\r\n        }\r\n      }\r\n      \r\n    } catch (error) {\r\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to load user session' });\r\n      throw error;\r\n    } finally {\r\n      dispatch({ type: 'SET_LOADING', payload: false });\r\n      isLoadingSession.current = false;\r\n    }\r\n  }, [state.questionsData, resumeSurveyTimer, startSurveyTimer]);\r\n\r\n  const findNextUnansweredQuestion = useCallback((responses: QuestionResponse[], questionsData: Category[]) => {\r\n    const answeredQuestions = new Set(responses.map(r => r.questionId));\r\n    \r\n    for (let categoryIndex = 0; categoryIndex < questionsData.length; categoryIndex++) {\r\n      const category = questionsData[categoryIndex];\r\n      \r\n      for (let subcategoryIndex = 0; subcategoryIndex < category.subcategories.length; subcategoryIndex++) {\r\n        const subcategory = category.subcategories[subcategoryIndex];\r\n        \r\n        for (let topicIndex = 0; topicIndex < subcategory.topics.length; topicIndex++) {\r\n          const topic = subcategory.topics[topicIndex];\r\n          \r\n          for (let questionIndex = 0; questionIndex < topic.questions.length; questionIndex++) {\r\n            const questionId = `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\r\n            \r\n            if (!answeredQuestions.has(questionId)) {\r\n              return {\r\n                categoryIndex,\r\n                subcategoryIndex,\r\n                topicIndex,\r\n                questionIndex\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (questionsData.length > 0) {\r\n      const lastCategory = questionsData[questionsData.length - 1];\r\n      const lastSubcategory = lastCategory.subcategories[lastCategory.subcategories.length - 1];\r\n      const lastTopic = lastSubcategory.topics[lastSubcategory.topics.length - 1];\r\n      \r\n      return {\r\n        categoryIndex: questionsData.length - 1,\r\n        subcategoryIndex: lastCategory.subcategories.length - 1,\r\n        topicIndex: lastSubcategory.topics.length - 1,\r\n        questionIndex: lastTopic.questions.length - 1\r\n      };\r\n    }\r\n    \r\n    return { categoryIndex: 0, subcategoryIndex: 0, topicIndex: 0, questionIndex: 0 };\r\n  }, []);\r\n\r\n  const saveResponse = useCallback(async (response: QuestionResponse) => {\r\n  try {\r\n    console.log('FormContext: Saving response:', response);\r\n    await api.saveResponse(response);\r\n    dispatch({ type: 'ADD_RESPONSE', payload: response });\r\n    dispatch({ type: 'SET_LAST_SAVE_TIME', payload: Date.now() });\r\n    \r\n    // Only count non-attention check responses for progress\r\n    const wasNewResponse = !state.responses.has(response.questionId);\r\n    const isActualQuestion = !response.questionId.startsWith('ATTENTION_CHECK_');\r\n    \r\n    if (wasNewResponse && isActualQuestion) {\r\n      const completedQuestions = Array.from(state.responses.keys())\r\n        .filter(questionId => !questionId.startsWith('ATTENTION_CHECK_'))\r\n        .length + 1; // +1 for the response we just added\r\n      \r\n      dispatch({ type: 'UPDATE_PROGRESS', payload: { completedQuestions } });\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.error('FormContext: Error saving response:', error);\r\n    dispatch({ type: 'SET_ERROR', payload: 'Failed to save response' });\r\n    throw error;\r\n  }\r\n}, [state.responses]);\r\n\r\n  const navigateToPosition = useCallback(async (categoryIndex: number, subcategoryIndex: number, topicIndex: number, questionIndex: number) => {\r\n    const newPosition = { categoryIndex, subcategoryIndex, topicIndex, questionIndex };\r\n    dispatch({ type: 'SET_CURRENT_POSITION', payload: newPosition });\r\n\r\n    if (state.sessionId) {\r\n      try {\r\n        await api.updateUserProgress(state.sessionId, {\r\n          currentCategory: categoryIndex,\r\n          currentSubcategory: subcategoryIndex,\r\n          currentTopic: topicIndex,\r\n          currentQuestion: questionIndex\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to save navigation progress:', error);\r\n      }\r\n    }\r\n  }, [state.sessionId]);\r\n\r\n  const getCurrentQuestionData = useCallback(() => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex, questionIndex } = state.currentPosition;\r\n    \r\n    if (!state.questionsData[categoryIndex]) return null;\r\n    \r\n    const category = state.questionsData[categoryIndex];\r\n    const subcategory = category.subcategories[subcategoryIndex];\r\n    const topic = subcategory?.topics[topicIndex];\r\n    const question = topic?.questions[questionIndex];\r\n    \r\n    if (!question) return null;\r\n    \r\n    return {\r\n      category: category.category,\r\n      subcategory: subcategory.subcategory,\r\n      topic: topic.topic,\r\n      question,\r\n      questionId: `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`\r\n    };\r\n  }, [state.currentPosition, state.questionsData]);\r\n\r\n  const getCurrentQuestion = useCallback(() => {\r\n    const data = getCurrentQuestionData();\r\n    return data?.question || null;\r\n  }, [getCurrentQuestionData]);\r\n\r\n  const navigateToNext = useCallback(async () => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex, questionIndex } = state.currentPosition;\r\n    const category = state.questionsData[categoryIndex];\r\n    \r\n    if (!category) return;\r\n    \r\n    const subcategory = category.subcategories[subcategoryIndex];\r\n    const topic = subcategory?.topics[topicIndex];\r\n    \r\n    if (!topic) return;\r\n\r\n    let newPosition = { ...state.currentPosition };\r\n\r\n    if (questionIndex < topic.questions.length - 1) {\r\n      newPosition.questionIndex = questionIndex + 1;\r\n    } else if (topicIndex < subcategory.topics.length - 1) {\r\n      newPosition.topicIndex = topicIndex + 1;\r\n      newPosition.questionIndex = 0;\r\n    } else if (subcategoryIndex < category.subcategories.length - 1) {\r\n      newPosition.subcategoryIndex = subcategoryIndex + 1;\r\n      newPosition.topicIndex = 0;\r\n      newPosition.questionIndex = 0;\r\n    } else if (categoryIndex < state.questionsData.length - 1) {\r\n      newPosition.categoryIndex = categoryIndex + 1;\r\n      newPosition.subcategoryIndex = 0;\r\n      newPosition.topicIndex = 0;\r\n      newPosition.questionIndex = 0;\r\n    } else {\r\n      dispatch({ type: 'SET_COMPLETED', payload: true });\r\n      return;\r\n    }\r\n\r\n    dispatch({ type: 'SET_CURRENT_POSITION', payload: newPosition });\r\n\r\n    if (state.sessionId) {\r\n      try {\r\n        await api.updateUserProgress(state.sessionId, {\r\n          currentCategory: newPosition.categoryIndex,\r\n          currentSubcategory: newPosition.subcategoryIndex,\r\n          currentTopic: newPosition.topicIndex,\r\n          currentQuestion: newPosition.questionIndex\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to save progress:', error);\r\n      }\r\n    }\r\n  }, [state.currentPosition, state.questionsData, state.sessionId]);\r\n\r\n  const navigateToPrevious = useCallback(async () => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex, questionIndex } = state.currentPosition;\r\n    \r\n    let newPosition = { ...state.currentPosition };\r\n\r\n    if (questionIndex > 0) {\r\n      newPosition.questionIndex = questionIndex - 1;\r\n    } else if (topicIndex > 0) {\r\n      const prevTopic = state.questionsData[categoryIndex].subcategories[subcategoryIndex].topics[topicIndex - 1];\r\n      newPosition.topicIndex = topicIndex - 1;\r\n      newPosition.questionIndex = prevTopic.questions.length - 1;\r\n    } else if (subcategoryIndex > 0) {\r\n      const prevSubcategory = state.questionsData[categoryIndex].subcategories[subcategoryIndex - 1];\r\n      const lastTopic = prevSubcategory.topics[prevSubcategory.topics.length - 1];\r\n      newPosition.subcategoryIndex = subcategoryIndex - 1;\r\n      newPosition.topicIndex = prevSubcategory.topics.length - 1;\r\n      newPosition.questionIndex = lastTopic.questions.length - 1;\r\n    } else if (categoryIndex > 0) {\r\n      const prevCategory = state.questionsData[categoryIndex - 1];\r\n      const lastSubcategory = prevCategory.subcategories[prevCategory.subcategories.length - 1];\r\n      const lastTopic = lastSubcategory.topics[lastSubcategory.topics.length - 1];\r\n      newPosition.categoryIndex = categoryIndex - 1;\r\n      newPosition.subcategoryIndex = prevCategory.subcategories.length - 1;\r\n      newPosition.topicIndex = lastSubcategory.topics.length - 1;\r\n      newPosition.questionIndex = lastTopic.questions.length - 1;\r\n    }\r\n\r\n    dispatch({ type: 'SET_CURRENT_POSITION', payload: newPosition });\r\n\r\n    if (state.sessionId) {\r\n      try {\r\n        await api.updateUserProgress(state.sessionId, {\r\n          currentCategory: newPosition.categoryIndex,\r\n          currentSubcategory: newPosition.subcategoryIndex,\r\n          currentTopic: newPosition.topicIndex,\r\n          currentQuestion: newPosition.questionIndex\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to save progress:', error);\r\n      }\r\n    }\r\n  }, [state.currentPosition, state.questionsData, state.sessionId]);\r\n\r\n  const calculateProgress = useCallback(() => {\r\n  const totalQuestions = state.progress.totalQuestions;\r\n  // Filter out attention check responses from the count\r\n  const completedQuestions = Array.from(state.responses.keys())\r\n    .filter(questionId => !questionId.startsWith('ATTENTION_CHECK_'))\r\n    .length;\r\n  return totalQuestions > 0 ? (completedQuestions / totalQuestions) * 100 : 0;\r\n}, [state.progress.totalQuestions, state.responses]);\r\n\r\n  const getTotalQuestionsInCurrentTopic = useCallback(() => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex } = state.currentPosition;\r\n    const topic = state.questionsData[categoryIndex]?.subcategories[subcategoryIndex]?.topics[topicIndex];\r\n    return topic?.questions.length || 0;\r\n  }, [state.currentPosition, state.questionsData]);\r\n\r\n  const getCompletedQuestionsInCurrentTopic = useCallback(() => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex } = state.currentPosition;\r\n    let completed = 0;\r\n    \r\n    const topic = state.questionsData[categoryIndex]?.subcategories[subcategoryIndex]?.topics[topicIndex];\r\n    if (!topic) return 0;\r\n    \r\n    topic.questions.forEach((_, questionIndex) => {\r\n      const questionId = `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\r\n      if (state.responses.has(questionId)) {\r\n        completed++;\r\n      }\r\n    });\r\n    \r\n    return completed;\r\n  }, [state.currentPosition, state.questionsData, state.responses]);\r\n\r\n  // Reset session function\r\n  const resetSession = useCallback(() => {\r\n    localStorage.removeItem('culturalSurveySessionId');\r\n    localStorage.removeItem('culturalSurveyStartTime');\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n      setTimerInterval(null);\r\n    }\r\n    surveyStartTimeRef.current = 0;\r\n    dispatch({ type: 'RESET_FORM' });\r\n  }, [timerInterval]);\r\n  \r\n  const value: FormContextType = {\r\n    state,\r\n    dispatch,\r\n    createUserSession,\r\n    saveResponse,\r\n    navigateToNext,\r\n    navigateToPrevious,\r\n    calculateProgress,\r\n    getCurrentQuestion,\r\n    getCurrentQuestionData,\r\n    getTotalQuestionsInCurrentTopic,\r\n    getCompletedQuestionsInCurrentTopic,\r\n    loadUserSession,\r\n    navigateToPosition,\r\n    resetSession,\r\n    startSurveyTimer,\r\n    resumeSurveyTimer,\r\n    formatTimeElapsed,\r\n    setAttentionCheckFailed,\r\n    setTiming,\r\n  };\r\n\r\n  return (\r\n    <FormContext.Provider value={value}>\r\n      {children}\r\n    </FormContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useForm() {\r\n  const context = useContext(FormContext);\r\n  if (context === undefined) {\r\n    throw new Error('useForm must be used within a FormProvider');\r\n  }\r\n  return context;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}