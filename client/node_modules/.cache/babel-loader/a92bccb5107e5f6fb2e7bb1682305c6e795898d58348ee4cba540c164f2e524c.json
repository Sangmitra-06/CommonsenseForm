{"ast":null,"code":"export const loadQuestionsData = async () => {\n  try {\n    console.log('Loading questions from public/questions.json...');\n    const response = await fetch('/questions.json');\n    if (!response.ok) {\n      throw new Error(`Failed to load questions: ${response.status} ${response.statusText}`);\n    }\n    const data = await response.json();\n\n    // Validate the data structure\n    if (!Array.isArray(data) || data.length === 0) {\n      throw new Error('Questions data is not in the expected format');\n    }\n\n    // Calculate totals for logging\n    const totalQuestions = data.reduce((sum, cat) => sum + cat.subcategories.reduce((subSum, sub) => subSum + sub.topics.reduce((topicSum, topic) => topicSum + topic.questions.length, 0), 0), 0);\n    console.log('Questions loaded successfully:', {\n      categories: data.length,\n      totalSubcategories: data.reduce((sum, cat) => sum + cat.subcategories.length, 0),\n      totalTopics: data.reduce((sum, cat) => sum + cat.subcategories.reduce((subSum, sub) => subSum + sub.topics.length, 0), 0),\n      totalQuestions\n    });\n    return data;\n  } catch (error) {\n    console.error('Error loading questions data:', error);\n    throw new Error('Failed to load questions data');\n  }\n};\nexport const validateAnswer = answer => {\n  if (!answer || answer.trim().length === 0) {\n    return {\n      isValid: false,\n      message: 'Please provide an answer or specify \"none\" if no answer exists'\n    };\n  }\n  if (answer.trim().length < 4) {\n    return {\n      isValid: false,\n      message: 'Please provide a more detailed answer (at least 4 characters) or specify \"none\"'\n    };\n  }\n  if (answer.length > 5000) {\n    return {\n      isValid: false,\n      message: 'Answer is too long (maximum 5000 characters)'\n    };\n  }\n  return {\n    isValid: true\n  };\n};\nexport const shouldShowAttentionCheck = questionCount => {\n  console.log('Checking if should show attention check:', {\n    questionCount,\n    isDivisibleBy7: questionCount > 0 && questionCount % 7 === 0,\n    result: questionCount > 0 && questionCount % 7 === 0\n  });\n  return questionCount > 0 && questionCount % 7 === 0;\n};\n\n// NEW: Improved attention check validation\n// NEW: Improved attention check validation\nexport const validateAttentionCheck = (userAnswer, expectedAnswers) => {\n  if (!userAnswer || typeof userAnswer !== 'string') {\n    console.log('Attention check failed: Empty or invalid answer');\n    return false;\n  }\n\n  // Clean and normalize the user's answer - handle multi-line input\n  const cleanAnswer = userAnswer.toLowerCase().replace(/\\r\\n/g, ' ') // Replace Windows line breaks with space\n  .replace(/\\n/g, ' ') // Replace Unix line breaks with space\n  .replace(/\\r/g, ' ') // Replace old Mac line breaks with space\n  .trim().replace(/[^\\w\\s]/g, '') // Remove punctuation\n  .replace(/\\s+/g, ' '); // Normalize all whitespace to single spaces\n\n  console.log('Validating attention check:', {\n    originalAnswer: userAnswer,\n    cleanAnswer: cleanAnswer,\n    expectedAnswers: expectedAnswers\n  });\n\n  // Check against all accepted answers\n  const isValid = expectedAnswers.some(acceptedAnswer => {\n    const cleanAccepted = acceptedAnswer.toLowerCase().trim();\n\n    // Exact match\n    if (cleanAnswer === cleanAccepted) {\n      console.log('Attention check passed: Exact match');\n      return true;\n    }\n\n    // Check if the answer contains the expected word (for cases like \"the sun is yellow\")\n    if (cleanAnswer.includes(cleanAccepted)) {\n      console.log('Attention check passed: Contains expected answer');\n      return true;\n    }\n\n    // Check for common variations\n    if (cleanAccepted === 'yellow' && (cleanAnswer.includes('gold') || cleanAnswer === 'golden')) {\n      console.log('Attention check passed: Yellow variation');\n      return true;\n    }\n    if (cleanAccepted === 'tuesday' && cleanAnswer === 'tue') {\n      console.log('Attention check passed: Tuesday abbreviation');\n      return true;\n    }\n    return false;\n  });\n  console.log('Attention check result:', isValid);\n  return isValid;\n};\n\n// Comprehensive quality analysis\n// Fixed version for helpers.ts\nexport const analyzeResponseQuality = answer => {\n  const issues = [];\n  let score = 100;\n  let isNoneResponse = false;\n  let isGibberish = false;\n  const text = answer.toLowerCase().trim();\n\n  // More lenient \"none\" patterns - only flag obviously lazy responses\n  const nonePatterns = [/^(none|n\\/a|na|nothing|no|idk|dk)$/i, /^(same|normal|usual|regular|typical)$/i];\n\n  // More specific legitimate none responses (don't penalize these)\n  const legitimateNonePatterns = [/^(none that i know|nothing that i know|not in my region|not applicable here)/i, /^(we don't have|not common here|not practiced in)/i];\n\n  // Check for none responses - but be more lenient\n  const hasNoneResponse = nonePatterns.some(pattern => pattern.test(text)) && !legitimateNonePatterns.some(pattern => pattern.test(text));\n  if (hasNoneResponse && text.length < 8) {\n    // Only flag very short \"none\" responses\n    isNoneResponse = true;\n    issues.push('Very brief response - consider adding more detail if possible');\n    score -= 25; // Reduced penalty\n  }\n\n  // Check for gibberish patterns\n  const gibberishPatterns = [/^[bcdfghjklmnpqrstvwxyz]{6,}$/i,\n  // Too many consonants\n  /^[aeiou]{6,}$/i,\n  // Too many vowels\n  /(.{3,})\\1{2,}/,\n  // Repeated patterns (abcabc)\n  /^[^a-z\\s]*$/i,\n  // No letters at all\n  /^[a-z]{8,}$/i // Long strings without spaces\n  ];\n\n  // Keyboard mashing patterns\n  const mashingPatterns = [/qwerty|asdf|zxcv|hjkl|yuiop/i, /abcd|1234|test|xxx|yyy|zzz/i, /(.)\\1{4,}/ // Same character repeated 5+ times\n  ];\n\n  // Check for gibberish (only add message once)\n  const hasGibberish = gibberishPatterns.some(pattern => pattern.test(text));\n  if (hasGibberish) {\n    isGibberish = true;\n    issues.push('Appears to be random characters or gibberish');\n    score -= 60;\n  }\n\n  // Check for keyboard mashing (only add message once)\n  const hasMashing = mashingPatterns.some(pattern => pattern.test(text));\n  if (hasMashing && !hasGibberish) {\n    // Only add if not already marked as gibberish\n    isGibberish = true;\n    issues.push('Keyboard mashing or test input detected');\n    score -= 50;\n  }\n\n  // Check for excessive repetition of words\n  const words = text.split(/\\s+/).filter(word => word.length > 2);\n  const wordCount = {};\n  words.forEach(word => {\n    wordCount[word] = (wordCount[word] || 0) + 1;\n  });\n  const repeatedWords = Object.entries(wordCount).filter(([word, count]) => count > 3);\n  if (repeatedWords.length > 0) {\n    issues.push('Excessive word repetition');\n    score -= 30;\n  }\n\n  // Check for lack of specificity\n  const vaguePhrases = ['something', 'things', 'stuff', 'anything', 'everything'];\n  const vagueCount = vaguePhrases.reduce((count, phrase) => count + (text.match(new RegExp(`\\\\b${phrase}\\\\b`, 'g')) || []).length, 0);\n  if (vagueCount > 3) {\n    issues.push('Response lacks specific details');\n    score -= 15;\n  }\n\n  // Positive indicators\n  const positiveIndicators = [/\\b(example|for instance|specifically|traditionally|commonly|usually|typically)\\b/i, /\\b(in my region|in our area|locally|here we|we usually|in our culture)\\b/i, /\\b(such as|like|including|consists of|involves|includes)\\b/i];\n  let positiveCount = 0;\n  positiveIndicators.forEach(pattern => {\n    if (pattern.test(text)) positiveCount++;\n  });\n  if (positiveCount > 0) {\n    score += Math.min(positiveCount * 8, 20);\n  }\n  score = Math.max(0, Math.min(100, score));\n  return {\n    isLowQuality: score < 30,\n    issues,\n    score,\n    isNoneResponse,\n    isGibberish\n  };\n};\nexport const analyzeUserPattern = responses => {\n  const warnings = [];\n  let suspiciousPattern = false;\n  if (responses.length < 3) {\n    // Increased minimum threshold\n    return {\n      suspiciousPattern: false,\n      // Don't flag with too few responses\n      warnings,\n      noneResponseRate: 0,\n      gibberishResponseRate: 0,\n      fastResponseRate: 0,\n      issueType: null\n    };\n  }\n\n  // Rest of the function stays the same but with higher thresholds\n  let noneCount = 0;\n  let gibberishCount = 0;\n  let fastResponseCount = 0;\n  responses.forEach(response => {\n    const analysis = analyzeResponseQuality(response.answer);\n    if (analysis.isNoneResponse) noneCount++;\n    if (analysis.isGibberish) gibberishCount++;\n    if (response.timeSpent < 5) fastResponseCount++; // Reduced threshold\n  });\n  const noneResponseRate = noneCount / responses.length * 100;\n  const gibberishResponseRate = gibberishCount / responses.length * 100;\n  const fastResponseRate = fastResponseCount / responses.length * 100;\n  let primaryIssue = null;\n\n  // Higher thresholds for flagging patterns\n  if (noneResponseRate >= 30) {\n    // Increased from 30%\n    warnings.push(`High rate of \"none\" responses (${noneResponseRate.toFixed(1)}%)`);\n    suspiciousPattern = true;\n    primaryIssue = 'none';\n  }\n  if (gibberishResponseRate >= 40) {\n    // Increased from 30%\n    warnings.push(`High rate of gibberish responses (${gibberishResponseRate.toFixed(1)}%)`);\n    suspiciousPattern = true;\n    if (!primaryIssue) primaryIssue = 'gibberish';\n  }\n  if (fastResponseRate >= 30) {\n    // Increased from 30%\n    warnings.push(`High rate of very quick responses (${fastResponseRate.toFixed(1)}%)`);\n    suspiciousPattern = true;\n    if (!primaryIssue) primaryIssue = 'speed';\n  }\n  return {\n    suspiciousPattern,\n    warnings,\n    noneResponseRate,\n    gibberishResponseRate,\n    fastResponseRate,\n    issueType: primaryIssue\n  };\n};\n// NEW: Enhanced attention check generation with multiple correct answers\nexport const generateAttentionCheck = (currentCategory, currentTopic, userInfo) => {\n  const checks = [{\n    question: 'This survey is about cultural practices in which country? Please type the country name.',\n    correctAnswers: ['india', 'bharat'],\n    type: 'basic'\n  }];\n\n  // Add personal verification if userInfo available\n  if (userInfo) {\n    checks.push({\n      question: `What region of India did you specify at the beginning of this survey? Please write the name of the region (North, South, East, West, or Central).`,\n      correctAnswers: [userInfo.region.toLowerCase()],\n      type: 'personal'\n    });\n  }\n  const randomCheck = checks[Math.floor(Math.random() * checks.length)];\n  return {\n    question: randomCheck.question,\n    options: [],\n    // Not used for text input\n    correctAnswer: 0,\n    // Not used for text input\n    expectedAnswer: randomCheck.correctAnswers[0],\n    // Primary expected answer for backward compatibility\n    expectedAnswers: randomCheck.correctAnswers,\n    // NEW: Array of acceptable answers\n    currentTopic,\n    currentCategory,\n    type: randomCheck.type\n  };\n};\n\n// Utility functions\nexport const generateQuestionId = (categoryIndex, subcategoryIndex, topicIndex, questionIndex) => {\n  return `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\n};\nexport const formatTime = seconds => {\n  const mins = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\n};\nexport const debounce = (func, wait) => {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(null, args), wait);\n  };\n};\nexport const getEstimatedTimeRemaining = (totalQuestions, completedQuestions, averageTimePerQuestion = 120) => {\n  const remainingQuestions = totalQuestions - completedQuestions;\n  const estimatedSeconds = remainingQuestions * averageTimePerQuestion;\n  if (estimatedSeconds < 3600) {\n    const minutes = Math.ceil(estimatedSeconds / 60);\n    return `~${minutes} minute${minutes !== 1 ? 's' : ''} remaining`;\n  } else {\n    const hours = Math.ceil(estimatedSeconds / 3600);\n    return `~${hours} hour${hours !== 1 ? 's' : ''} remaining`;\n  }\n};","map":{"version":3,"names":["loadQuestionsData","console","log","response","fetch","ok","Error","status","statusText","data","json","Array","isArray","length","totalQuestions","reduce","sum","cat","subcategories","subSum","sub","topics","topicSum","topic","questions","categories","totalSubcategories","totalTopics","error","validateAnswer","answer","trim","isValid","message","shouldShowAttentionCheck","questionCount","isDivisibleBy7","result","validateAttentionCheck","userAnswer","expectedAnswers","cleanAnswer","toLowerCase","replace","originalAnswer","some","acceptedAnswer","cleanAccepted","includes","analyzeResponseQuality","issues","score","isNoneResponse","isGibberish","text","nonePatterns","legitimateNonePatterns","hasNoneResponse","pattern","test","push","gibberishPatterns","mashingPatterns","hasGibberish","hasMashing","words","split","filter","word","wordCount","forEach","repeatedWords","Object","entries","count","vaguePhrases","vagueCount","phrase","match","RegExp","positiveIndicators","positiveCount","Math","min","max","isLowQuality","analyzeUserPattern","responses","warnings","suspiciousPattern","noneResponseRate","gibberishResponseRate","fastResponseRate","issueType","noneCount","gibberishCount","fastResponseCount","analysis","timeSpent","primaryIssue","toFixed","generateAttentionCheck","currentCategory","currentTopic","userInfo","checks","question","correctAnswers","type","region","randomCheck","floor","random","options","correctAnswer","expectedAnswer","generateQuestionId","categoryIndex","subcategoryIndex","topicIndex","questionIndex","formatTime","seconds","mins","secs","toString","padStart","debounce","func","wait","timeout","args","clearTimeout","setTimeout","apply","getEstimatedTimeRemaining","completedQuestions","averageTimePerQuestion","remainingQuestions","estimatedSeconds","minutes","ceil","hours"],"sources":["C:/Users/sangm/OneDrive - Brock University/CommonsenseForm/client/src/utils/helpers.ts"],"sourcesContent":["import { Category, AttentionCheck } from '../types/index.ts';\r\n\r\nexport const loadQuestionsData = async (): Promise<Category[]> => {\r\n  try {\r\n    console.log('Loading questions from public/questions.json...');\r\n    \r\n    const response = await fetch('/questions.json');\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(`Failed to load questions: ${response.status} ${response.statusText}`);\r\n    }\r\n    \r\n    const data: Category[] = await response.json();\r\n    \r\n    // Validate the data structure\r\n    if (!Array.isArray(data) || data.length === 0) {\r\n      throw new Error('Questions data is not in the expected format');\r\n    }\r\n    \r\n    // Calculate totals for logging\r\n    const totalQuestions = data.reduce((sum, cat) => \r\n      sum + cat.subcategories.reduce((subSum, sub) => \r\n        subSum + sub.topics.reduce((topicSum, topic) => topicSum + topic.questions.length, 0), 0), 0);\r\n    \r\n    console.log('Questions loaded successfully:', {\r\n      categories: data.length,\r\n      totalSubcategories: data.reduce((sum, cat) => sum + cat.subcategories.length, 0),\r\n      totalTopics: data.reduce((sum, cat) => \r\n        sum + cat.subcategories.reduce((subSum, sub) => subSum + sub.topics.length, 0), 0),\r\n      totalQuestions\r\n    });\r\n    \r\n    return data;\r\n    \r\n  } catch (error) {\r\n    console.error('Error loading questions data:', error);\r\n    throw new Error('Failed to load questions data');\r\n  }\r\n};\r\n\r\nexport const validateAnswer = (answer: string): { isValid: boolean; message?: string } => {\r\n  if (!answer || answer.trim().length === 0) {\r\n    return { isValid: false, message: 'Please provide an answer or specify \"none\" if no answer exists' };\r\n  }\r\n  \r\n  if (answer.trim().length < 4) {\r\n    return { isValid: false, message: 'Please provide a more detailed answer (at least 4 characters) or specify \"none\"' };\r\n  }\r\n  \r\n  if (answer.length > 5000) {\r\n    return { isValid: false, message: 'Answer is too long (maximum 5000 characters)' };\r\n  }\r\n  \r\n  return { isValid: true };\r\n};\r\n\r\nexport const shouldShowAttentionCheck = (questionCount: number): boolean => {\r\n  console.log('Checking if should show attention check:', {\r\n    questionCount,\r\n    isDivisibleBy7: questionCount > 0 && questionCount % 7 === 0,\r\n    result: questionCount > 0 && questionCount % 7 === 0\r\n  });\r\n  \r\n  return questionCount > 0 && questionCount % 7 === 0;\r\n};\r\n\r\n// NEW: Improved attention check validation\r\n// NEW: Improved attention check validation\r\nexport const validateAttentionCheck = (userAnswer: string, expectedAnswers: string[]): boolean => {\r\n  if (!userAnswer || typeof userAnswer !== 'string') {\r\n    console.log('Attention check failed: Empty or invalid answer');\r\n    return false;\r\n  }\r\n\r\n  // Clean and normalize the user's answer - handle multi-line input\r\n  const cleanAnswer = userAnswer\r\n    .toLowerCase()\r\n    .replace(/\\r\\n/g, ' ') // Replace Windows line breaks with space\r\n    .replace(/\\n/g, ' ')   // Replace Unix line breaks with space\r\n    .replace(/\\r/g, ' ')   // Replace old Mac line breaks with space\r\n    .trim()\r\n    .replace(/[^\\w\\s]/g, '') // Remove punctuation\r\n    .replace(/\\s+/g, ' '); // Normalize all whitespace to single spaces\r\n\r\n  console.log('Validating attention check:', {\r\n    originalAnswer: userAnswer,\r\n    cleanAnswer: cleanAnswer,\r\n    expectedAnswers: expectedAnswers\r\n  });\r\n\r\n  // Check against all accepted answers\r\n  const isValid = expectedAnswers.some(acceptedAnswer => {\r\n    const cleanAccepted = acceptedAnswer.toLowerCase().trim();\r\n    \r\n    // Exact match\r\n    if (cleanAnswer === cleanAccepted) {\r\n      console.log('Attention check passed: Exact match');\r\n      return true;\r\n    }\r\n    \r\n    // Check if the answer contains the expected word (for cases like \"the sun is yellow\")\r\n    if (cleanAnswer.includes(cleanAccepted)) {\r\n      console.log('Attention check passed: Contains expected answer');\r\n      return true;\r\n    }\r\n    \r\n    // Check for common variations\r\n    if (cleanAccepted === 'yellow' && (cleanAnswer.includes('gold') || cleanAnswer === 'golden')) {\r\n      console.log('Attention check passed: Yellow variation');\r\n      return true;\r\n    }\r\n    \r\n    if (cleanAccepted === 'tuesday' && cleanAnswer === 'tue') {\r\n      console.log('Attention check passed: Tuesday abbreviation');\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  });\r\n\r\n  console.log('Attention check result:', isValid);\r\n  return isValid;\r\n};\r\n\r\n// Comprehensive quality analysis\r\n// Fixed version for helpers.ts\r\nexport const analyzeResponseQuality = (answer: string): {\r\n  isLowQuality: boolean;\r\n  issues: string[];\r\n  score: number;\r\n  isNoneResponse: boolean;\r\n  isGibberish: boolean;\r\n} => {\r\n  const issues: string[] = [];\r\n  let score = 100;\r\n  let isNoneResponse = false;\r\n  let isGibberish = false;\r\n\r\n  const text = answer.toLowerCase().trim();\r\n  \r\n  // More lenient \"none\" patterns - only flag obviously lazy responses\r\n  const nonePatterns = [\r\n    /^(none|n\\/a|na|nothing|no|idk|dk)$/i,\r\n    /^(same|normal|usual|regular|typical)$/i,\r\n  ];\r\n\r\n  // More specific legitimate none responses (don't penalize these)\r\n  const legitimateNonePatterns = [\r\n    /^(none that i know|nothing that i know|not in my region|not applicable here)/i,\r\n    /^(we don't have|not common here|not practiced in)/i,\r\n  ];\r\n\r\n  // Check for none responses - but be more lenient\r\n  const hasNoneResponse = nonePatterns.some(pattern => pattern.test(text)) && \r\n                         !legitimateNonePatterns.some(pattern => pattern.test(text));\r\n  \r\n  if (hasNoneResponse && text.length < 8) { // Only flag very short \"none\" responses\r\n    isNoneResponse = true;\r\n    issues.push('Very brief response - consider adding more detail if possible');\r\n    score -= 25; // Reduced penalty\r\n  }\r\n\r\n  // Check for gibberish patterns\r\n  const gibberishPatterns = [\r\n    /^[bcdfghjklmnpqrstvwxyz]{6,}$/i, // Too many consonants\r\n    /^[aeiou]{6,}$/i, // Too many vowels\r\n    /(.{3,})\\1{2,}/, // Repeated patterns (abcabc)\r\n    /^[^a-z\\s]*$/i, // No letters at all\r\n    /^[a-z]{8,}$/i, // Long strings without spaces\r\n  ];\r\n\r\n  // Keyboard mashing patterns\r\n  const mashingPatterns = [\r\n    /qwerty|asdf|zxcv|hjkl|yuiop/i,\r\n    /abcd|1234|test|xxx|yyy|zzz/i,\r\n    /(.)\\1{4,}/, // Same character repeated 5+ times\r\n  ];\r\n\r\n  // Check for gibberish (only add message once)\r\n  const hasGibberish = gibberishPatterns.some(pattern => pattern.test(text));\r\n  if (hasGibberish) {\r\n    isGibberish = true;\r\n    issues.push('Appears to be random characters or gibberish');\r\n    score -= 60;\r\n  }\r\n\r\n  // Check for keyboard mashing (only add message once)\r\n  const hasMashing = mashingPatterns.some(pattern => pattern.test(text));\r\n  if (hasMashing && !hasGibberish) { // Only add if not already marked as gibberish\r\n    isGibberish = true;\r\n    issues.push('Keyboard mashing or test input detected');\r\n    score -= 50;\r\n  }\r\n\r\n  // Check for excessive repetition of words\r\n  const words = text.split(/\\s+/).filter(word => word.length > 2);\r\n  const wordCount = {};\r\n  words.forEach(word => {\r\n    wordCount[word] = (wordCount[word] || 0) + 1;\r\n  });\r\n\r\n  const repeatedWords = Object.entries(wordCount).filter(([word, count]) => (count as number) > 3);\r\n  if (repeatedWords.length > 0) {\r\n    issues.push('Excessive word repetition');\r\n    score -= 30;\r\n  }\r\n\r\n  // Check for lack of specificity\r\n  const vaguePhrases = ['something', 'things', 'stuff', 'anything', 'everything'];\r\n  const vagueCount = vaguePhrases.reduce((count, phrase) => \r\n    count + (text.match(new RegExp(`\\\\b${phrase}\\\\b`, 'g')) || []).length, 0\r\n  );\r\n  \r\n  if (vagueCount > 3) {\r\n    issues.push('Response lacks specific details');\r\n    score -= 15;\r\n  }\r\n\r\n  // Positive indicators\r\n  const positiveIndicators = [\r\n    /\\b(example|for instance|specifically|traditionally|commonly|usually|typically)\\b/i,\r\n    /\\b(in my region|in our area|locally|here we|we usually|in our culture)\\b/i,\r\n    /\\b(such as|like|including|consists of|involves|includes)\\b/i,\r\n  ];\r\n\r\n  let positiveCount = 0;\r\n  positiveIndicators.forEach(pattern => {\r\n    if (pattern.test(text)) positiveCount++;\r\n  });\r\n\r\n  if (positiveCount > 0) {\r\n    score += Math.min(positiveCount * 8, 20);\r\n  }\r\n\r\n  score = Math.max(0, Math.min(100, score));\r\n  \r\n  return {\r\n    isLowQuality: score < 30,\r\n    issues,\r\n    score,\r\n    isNoneResponse,\r\n    isGibberish\r\n  };\r\n};\r\n\r\nexport const analyzeUserPattern = (responses: Array<{answer: string, timeSpent: number}>): {\r\n  suspiciousPattern: boolean;\r\n  warnings: string[];\r\n  noneResponseRate: number;\r\n  gibberishResponseRate: number;\r\n  fastResponseRate: number;\r\n  issueType: string | null;\r\n} => {\r\n  const warnings: string[] = [];\r\n  let suspiciousPattern = false;\r\n\r\n  if (responses.length < 3) { // Increased minimum threshold\r\n    return { \r\n      suspiciousPattern: false, // Don't flag with too few responses\r\n      warnings, \r\n      noneResponseRate: 0,\r\n      gibberishResponseRate: 0,\r\n      fastResponseRate: 0,\r\n      issueType: null\r\n    };\r\n  }\r\n\r\n  // Rest of the function stays the same but with higher thresholds\r\n  let noneCount = 0;\r\n  let gibberishCount = 0;\r\n  let fastResponseCount = 0;\r\n\r\n  responses.forEach(response => {\r\n    const analysis = analyzeResponseQuality(response.answer);\r\n    \r\n    if (analysis.isNoneResponse) noneCount++;\r\n    if (analysis.isGibberish) gibberishCount++;\r\n    if (response.timeSpent < 5) fastResponseCount++; // Reduced threshold\r\n  });\r\n\r\n  const noneResponseRate = (noneCount / responses.length) * 100;\r\n  const gibberishResponseRate = (gibberishCount / responses.length) * 100;\r\n  const fastResponseRate = (fastResponseCount / responses.length) * 100;\r\n\r\n  let primaryIssue: string | null = null;\r\n\r\n  // Higher thresholds for flagging patterns\r\n  if (noneResponseRate >= 30) { // Increased from 30%\r\n    warnings.push(`High rate of \"none\" responses (${noneResponseRate.toFixed(1)}%)`);\r\n    suspiciousPattern = true;\r\n    primaryIssue = 'none';\r\n  }\r\n\r\n  if (gibberishResponseRate >= 40) { // Increased from 30%\r\n    warnings.push(`High rate of gibberish responses (${gibberishResponseRate.toFixed(1)}%)`);\r\n    suspiciousPattern = true;\r\n    if (!primaryIssue) primaryIssue = 'gibberish';\r\n  }\r\n\r\n  if (fastResponseRate >= 30) { // Increased from 30%\r\n    warnings.push(`High rate of very quick responses (${fastResponseRate.toFixed(1)}%)`);\r\n    suspiciousPattern = true;\r\n    if (!primaryIssue) primaryIssue = 'speed';\r\n  }\r\n\r\n  return { \r\n    suspiciousPattern, \r\n    warnings, \r\n    noneResponseRate,\r\n    gibberishResponseRate,\r\n    fastResponseRate,\r\n    issueType: primaryIssue\r\n  };\r\n};\r\n// NEW: Enhanced attention check generation with multiple correct answers\r\nexport const generateAttentionCheck = (\r\n  currentCategory: string,\r\n  currentTopic: string,\r\n  userInfo?: { region: string; age: number }\r\n): AttentionCheck => {\r\n  const checks = [\r\n    {\r\n      question: 'This survey is about cultural practices in which country? Please type the country name.',\r\n      correctAnswers: ['india', 'bharat'],\r\n      type: 'basic'\r\n    },\r\n   \r\n  ];\r\n\r\n  // Add personal verification if userInfo available\r\n  if (userInfo) {\r\n    checks.push({\r\n      question: `What region of India did you specify at the beginning of this survey? Please write the name of the region (North, South, East, West, or Central).`,\r\n      correctAnswers: [userInfo.region.toLowerCase()],\r\n      type: 'personal'\r\n    });\r\n  }\r\n\r\n  \r\n  \r\n  const randomCheck = checks[Math.floor(Math.random() * checks.length)];\r\n  \r\n  return {\r\n    question: randomCheck.question,\r\n    options: [], // Not used for text input\r\n    correctAnswer: 0, // Not used for text input\r\n    expectedAnswer: randomCheck.correctAnswers[0], // Primary expected answer for backward compatibility\r\n    expectedAnswers: randomCheck.correctAnswers, // NEW: Array of acceptable answers\r\n    currentTopic,\r\n    currentCategory,\r\n    type: randomCheck.type\r\n  };\r\n};\r\n\r\n// Utility functions\r\nexport const generateQuestionId = (\r\n  categoryIndex: number,\r\n  subcategoryIndex: number,\r\n  topicIndex: number,\r\n  questionIndex: number\r\n): string => {\r\n  return `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\r\n};\r\n\r\nexport const formatTime = (seconds: number): string => {\r\n  const mins = Math.floor(seconds / 60);\r\n  const secs = seconds % 60;\r\n  return `${mins}:${secs.toString().padStart(2, '0')}`;\r\n};\r\n\r\nexport const debounce = <T extends (...args: any[]) => any>(\r\n  func: T,\r\n  wait: number\r\n): ((...args: Parameters<T>) => void) => {\r\n  let timeout: ReturnType<typeof setTimeout>;\r\n  \r\n  return (...args: Parameters<T>) => {\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => func.apply(null, args), wait);\r\n  };\r\n};\r\n\r\nexport const getEstimatedTimeRemaining = (\r\n  totalQuestions: number,\r\n  completedQuestions: number,\r\n  averageTimePerQuestion: number = 120\r\n): string => {\r\n  const remainingQuestions = totalQuestions - completedQuestions;\r\n  const estimatedSeconds = remainingQuestions * averageTimePerQuestion;\r\n  \r\n  if (estimatedSeconds < 3600) {\r\n    const minutes = Math.ceil(estimatedSeconds / 60);\r\n    return `~${minutes} minute${minutes !== 1 ? 's' : ''} remaining`;\r\n  } else {\r\n    const hours = Math.ceil(estimatedSeconds / 3600);\r\n    return `~${hours} hour${hours !== 1 ? 's' : ''} remaining`;\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}