{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sangm\\\\OneDrive - Brock University\\\\CommonsenseForm\\\\client\\\\src\\\\context\\\\FormContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect, useCallback, useRef, useState } from 'react';\nimport { loadQuestionsData } from '../utils/helpers.ts';\nimport * as api from '../services/api.ts';\n\n// Timer constants\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SURVEY_TIME_LIMIT = 15 * 60 * 1000; // 15 minutes in milliseconds\nconst WARNING_TIME_REMAINING = 2 * 60 * 1000; // Show warning at 2 minutes remaining\nconst CRITICAL_TIME_REMAINING = 30 * 1000; // Show critical warning at 30 seconds\n\nconst initialState = {\n  sessionId: null,\n  userInfo: null,\n  currentPosition: {\n    categoryIndex: 0,\n    subcategoryIndex: 0,\n    topicIndex: 0,\n    questionIndex: 0\n  },\n  responses: new Map(),\n  progress: {\n    currentCategory: 0,\n    currentSubcategory: 0,\n    currentTopic: 0,\n    currentQuestion: 0,\n    completedQuestions: 0,\n    totalQuestions: 0,\n    completedTopics: [],\n    attentionChecksPassed: 0,\n    attentionChecksFailed: 0\n  },\n  isLoading: false,\n  error: null,\n  questionsData: [],\n  startTime: 0,\n  lastSaveTime: 0,\n  isCompleted: false,\n  // Timer state\n  surveyStartTime: 0,\n  surveyTimeLimit: SURVEY_TIME_LIMIT,\n  surveyTimeRemaining: SURVEY_TIME_LIMIT,\n  showTimeWarning: false,\n  showTimeCritical: false,\n  surveyExpired: false\n};\nfunction formReducer(state, action) {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        isLoading: action.payload\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload\n      };\n    case 'SET_SESSION_ID':\n      return {\n        ...state,\n        sessionId: action.payload\n      };\n    case 'SET_USER_INFO':\n      return {\n        ...state,\n        userInfo: action.payload\n      };\n    case 'SET_QUESTIONS_DATA':\n      return {\n        ...state,\n        questionsData: action.payload\n      };\n    case 'SET_CURRENT_POSITION':\n      return {\n        ...state,\n        currentPosition: action.payload\n      };\n    case 'ADD_RESPONSE':\n      const newResponses = new Map(state.responses);\n      newResponses.set(action.payload.questionId, action.payload);\n      return {\n        ...state,\n        responses: newResponses\n      };\n    case 'UPDATE_PROGRESS':\n      return {\n        ...state,\n        progress: {\n          ...state.progress,\n          ...action.payload\n        }\n      };\n    case 'SET_RESPONSES':\n      const responseMap = new Map();\n      action.payload.forEach(response => {\n        responseMap.set(response.questionId, response);\n      });\n      return {\n        ...state,\n        responses: responseMap\n      };\n    case 'SET_START_TIME':\n      return {\n        ...state,\n        startTime: action.payload\n      };\n    case 'SET_LAST_SAVE_TIME':\n      return {\n        ...state,\n        lastSaveTime: action.payload\n      };\n    case 'SET_COMPLETED':\n      return {\n        ...state,\n        isCompleted: action.payload\n      };\n    case 'RESET_FORM':\n      return {\n        ...initialState,\n        questionsData: state.questionsData\n      };\n    // Timer cases\n    case 'START_SURVEY_TIMER':\n      return {\n        ...state,\n        surveyStartTime: Date.now(),\n        surveyTimeRemaining: state.surveyTimeLimit,\n        showTimeWarning: false,\n        showTimeCritical: false,\n        surveyExpired: false\n      };\n    case 'UPDATE_TIMER':\n      return {\n        ...state,\n        surveyTimeRemaining: action.payload.timeRemaining,\n        showTimeWarning: action.payload.showWarning,\n        showTimeCritical: action.payload.showCritical\n      };\n    case 'EXPIRE_SURVEY':\n      return {\n        ...state,\n        surveyExpired: true,\n        surveyTimeRemaining: 0,\n        isCompleted: true\n      };\n    default:\n      return state;\n  }\n}\n\n// Updated interface\n\nconst FormContext = /*#__PURE__*/createContext(undefined);\nexport function FormProvider({\n  children\n}) {\n  _s();\n  const [state, dispatch] = useReducer(formReducer, initialState);\n  const hasLoadedQuestions = useRef(false);\n  const isLoadingSession = useRef(false);\n  const [timerInterval, setTimerInterval] = useState(null);\n  const surveyStartTimeRef = useRef(0); // Add this ref to track start time\n\n  // Load questions data only once\n  useEffect(() => {\n    if (hasLoadedQuestions.current) return;\n    const loadData = async () => {\n      try {\n        hasLoadedQuestions.current = true;\n        dispatch({\n          type: 'SET_LOADING',\n          payload: true\n        });\n        dispatch({\n          type: 'SET_ERROR',\n          payload: null\n        });\n        console.log('FormContext: Loading questions data...');\n        const data = await loadQuestionsData();\n        console.log('FormContext: Questions loaded:', data.length, 'categories');\n        dispatch({\n          type: 'SET_QUESTIONS_DATA',\n          payload: data\n        });\n        const totalQuestions = getTotalQuestions(data);\n        console.log('FormContext: Total questions calculated:', totalQuestions);\n        dispatch({\n          type: 'UPDATE_PROGRESS',\n          payload: {\n            totalQuestions\n          }\n        });\n      } catch (error) {\n        console.error('FormContext: Error loading questions:', error);\n        dispatch({\n          type: 'SET_ERROR',\n          payload: 'Failed to load questions data. Please refresh the page.'\n        });\n        hasLoadedQuestions.current = false;\n      } finally {\n        dispatch({\n          type: 'SET_LOADING',\n          payload: false\n        });\n      }\n    };\n    loadData();\n  }, []);\n\n  // Calculate total questions\n  const getTotalQuestions = questionsData => {\n    return questionsData.reduce((total, category) => {\n      return total + category.subcategories.reduce((subTotal, subcategory) => {\n        return subTotal + subcategory.topics.reduce((topicTotal, topic) => {\n          return topicTotal + topic.questions.length;\n        }, 0);\n      }, 0);\n    }, 0);\n  };\n\n  // Auto-complete survey when time expires\n  const completeExpiredSurvey = useCallback(async () => {\n    if (state.sessionId) {\n      try {\n        console.log('Survey time expired, auto-completing...');\n        await api.completeUser(state.sessionId);\n        dispatch({\n          type: 'SET_COMPLETED',\n          payload: true\n        });\n      } catch (error) {\n        console.error('Error auto-completing expired survey:', error);\n      }\n    }\n  }, [state.sessionId]);\n  // FIXED: Start timer function\n  const startSurveyTimer = useCallback(() => {\n    const startTime = Date.now();\n    console.log('Starting survey timer at:', new Date(startTime).toISOString());\n\n    // Update both state and ref\n    dispatch({\n      type: 'START_SURVEY_TIMER'\n    });\n    surveyStartTimeRef.current = startTime;\n\n    // Clear any existing timer\n    if (timerInterval) {\n      clearInterval(timerInterval);\n    }\n\n    // Start new timer using the ref value\n    const interval = setInterval(() => {\n      const now = Date.now();\n      const elapsed = now - surveyStartTimeRef.current; // Use ref instead of state\n      const remaining = Math.max(0, SURVEY_TIME_LIMIT - elapsed);\n      console.log('Timer update:', {\n        elapsed: Math.floor(elapsed / 1000) + 's',\n        remaining: Math.floor(remaining / 1000) + 's'\n      });\n      const showWarning = remaining <= WARNING_TIME_REMAINING && remaining > CRITICAL_TIME_REMAINING;\n      const showCritical = remaining <= CRITICAL_TIME_REMAINING && remaining > 0;\n      if (remaining <= 0) {\n        console.log('Timer expired!');\n        dispatch({\n          type: 'EXPIRE_SURVEY'\n        });\n        clearInterval(interval);\n        setTimerInterval(null);\n        completeExpiredSurvey();\n      } else {\n        dispatch({\n          type: 'UPDATE_TIMER',\n          payload: {\n            timeRemaining: remaining,\n            showWarning,\n            showCritical\n          }\n        });\n      }\n    }, 1000); // Update every second\n\n    setTimerInterval(interval);\n  }, [timerInterval, completeExpiredSurvey]);\n\n  // FIXED: Resume timer function\n  const resumeSurveyTimer = useCallback(startTime => {\n    console.log('Resuming survey timer from:', new Date(startTime).toISOString());\n    const now = Date.now();\n    const elapsed = now - startTime;\n    const remaining = Math.max(0, SURVEY_TIME_LIMIT - elapsed);\n    console.log('Resume timer:', {\n      startTime: new Date(startTime).toISOString(),\n      elapsed: Math.floor(elapsed / 1000) + 's',\n      remaining: Math.floor(remaining / 1000) + 's'\n    });\n    if (remaining <= 0) {\n      console.log('Survey already expired on resume');\n      dispatch({\n        type: 'EXPIRE_SURVEY'\n      });\n      completeExpiredSurvey();\n      return;\n    }\n\n    // Set the ref to the original start time\n    surveyStartTimeRef.current = startTime;\n\n    // Update state\n    dispatch({\n      type: 'UPDATE_TIMER',\n      payload: {\n        timeRemaining: remaining,\n        showWarning: remaining <= WARNING_TIME_REMAINING,\n        showCritical: remaining <= CRITICAL_TIME_REMAINING\n      }\n    });\n\n    // Clear any existing timer\n    if (timerInterval) {\n      clearInterval(timerInterval);\n    }\n\n    // Start timer with correct start time\n    const interval = setInterval(() => {\n      const now = Date.now();\n      const elapsed = now - surveyStartTimeRef.current; // Use the original start time\n      const remaining = Math.max(0, SURVEY_TIME_LIMIT - elapsed);\n      const showWarning = remaining <= WARNING_TIME_REMAINING && remaining > CRITICAL_TIME_REMAINING;\n      const showCritical = remaining <= CRITICAL_TIME_REMAINING && remaining > 0;\n      if (remaining <= 0) {\n        dispatch({\n          type: 'EXPIRE_SURVEY'\n        });\n        clearInterval(interval);\n        setTimerInterval(null);\n        completeExpiredSurvey();\n      } else {\n        dispatch({\n          type: 'UPDATE_TIMER',\n          payload: {\n            timeRemaining: remaining,\n            showWarning,\n            showCritical\n          }\n        });\n      }\n    }, 1000);\n    setTimerInterval(interval);\n  }, [timerInterval, completeExpiredSurvey]);\n\n  // Clean up timer on unmount\n  useEffect(() => {\n    return () => {\n      if (timerInterval) {\n        clearInterval(timerInterval);\n      }\n    };\n  }, [timerInterval]);\n\n  // FIXED: Format time function\n  const formatTimeRemaining = useCallback(milliseconds => {\n    const totalSeconds = Math.max(0, Math.floor(milliseconds / 1000));\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n  }, []);\n\n  // FIXED: Create user session\n  const createUserSession = useCallback(async userInfo => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      const response = await api.createUser(userInfo);\n      dispatch({\n        type: 'SET_SESSION_ID',\n        payload: response.sessionId\n      });\n      dispatch({\n        type: 'SET_USER_INFO',\n        payload: userInfo\n      });\n      const startTime = Date.now();\n      dispatch({\n        type: 'SET_START_TIME',\n        payload: startTime\n      });\n\n      // Store session ID and start time in localStorage\n      localStorage.setItem('culturalSurveySessionId', response.sessionId);\n      localStorage.setItem('culturalSurveyStartTime', startTime.toString());\n\n      // Start the survey timer\n      console.log('Creating user session and starting timer');\n      startSurveyTimer();\n    } catch (error) {\n      dispatch({\n        type: 'SET_ERROR',\n        payload: 'Failed to create user session'\n      });\n      throw error;\n    } finally {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: false\n      });\n    }\n  }, [startSurveyTimer]);\n  const loadUserSession = useCallback(async sessionId => {\n    if (isLoadingSession.current) return;\n    try {\n      isLoadingSession.current = true;\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      console.log('FormContext: Loading user session...');\n      const user = await api.getUser(sessionId);\n      dispatch({\n        type: 'SET_SESSION_ID',\n        payload: sessionId\n      });\n      dispatch({\n        type: 'SET_USER_INFO',\n        payload: user.userInfo\n      });\n      dispatch({\n        type: 'SET_COMPLETED',\n        payload: user.isCompleted\n      });\n\n      // Load responses\n      console.log('FormContext: Loading user responses...');\n      const responses = await api.getUserResponses(sessionId);\n      console.log('FormContext: Responses loaded:', responses.length);\n      dispatch({\n        type: 'SET_RESPONSES',\n        payload: responses\n      });\n\n      // Recalculate total questions from current data\n      const totalQuestions = getTotalQuestions(state.questionsData);\n      const updatedProgress = {\n        ...user.progress,\n        totalQuestions,\n        completedQuestions: responses.length\n      };\n      dispatch({\n        type: 'UPDATE_PROGRESS',\n        payload: updatedProgress\n      });\n\n      // Find the correct starting position\n      const nextPosition = findNextUnansweredQuestion(responses, state.questionsData);\n      console.log('FormContext: Setting position to:', nextPosition);\n      dispatch({\n        type: 'SET_CURRENT_POSITION',\n        payload: nextPosition\n      });\n\n      // Resume timer if not completed\n      if (!user.isCompleted) {\n        const savedStartTime = localStorage.getItem('culturalSurveyStartTime');\n        if (savedStartTime) {\n          resumeSurveyTimer(parseInt(savedStartTime));\n        } else {\n          // If no start time found, start fresh timer\n          localStorage.setItem('culturalSurveyStartTime', Date.now().toString());\n          startSurveyTimer();\n        }\n      }\n    } catch (error) {\n      dispatch({\n        type: 'SET_ERROR',\n        payload: 'Failed to load user session'\n      });\n      throw error;\n    } finally {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: false\n      });\n      isLoadingSession.current = false;\n    }\n  }, [state.questionsData, resumeSurveyTimer, startSurveyTimer]);\n  const findNextUnansweredQuestion = useCallback((responses, questionsData) => {\n    const answeredQuestions = new Set(responses.map(r => r.questionId));\n    for (let categoryIndex = 0; categoryIndex < questionsData.length; categoryIndex++) {\n      const category = questionsData[categoryIndex];\n      for (let subcategoryIndex = 0; subcategoryIndex < category.subcategories.length; subcategoryIndex++) {\n        const subcategory = category.subcategories[subcategoryIndex];\n        for (let topicIndex = 0; topicIndex < subcategory.topics.length; topicIndex++) {\n          const topic = subcategory.topics[topicIndex];\n          for (let questionIndex = 0; questionIndex < topic.questions.length; questionIndex++) {\n            const questionId = `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\n            if (!answeredQuestions.has(questionId)) {\n              return {\n                categoryIndex,\n                subcategoryIndex,\n                topicIndex,\n                questionIndex\n              };\n            }\n          }\n        }\n      }\n    }\n    if (questionsData.length > 0) {\n      const lastCategory = questionsData[questionsData.length - 1];\n      const lastSubcategory = lastCategory.subcategories[lastCategory.subcategories.length - 1];\n      const lastTopic = lastSubcategory.topics[lastSubcategory.topics.length - 1];\n      return {\n        categoryIndex: questionsData.length - 1,\n        subcategoryIndex: lastCategory.subcategories.length - 1,\n        topicIndex: lastSubcategory.topics.length - 1,\n        questionIndex: lastTopic.questions.length - 1\n      };\n    }\n    return {\n      categoryIndex: 0,\n      subcategoryIndex: 0,\n      topicIndex: 0,\n      questionIndex: 0\n    };\n  }, []);\n  const saveResponse = useCallback(async response => {\n    try {\n      console.log('FormContext: Saving response:', response);\n      await api.saveResponse(response);\n      dispatch({\n        type: 'ADD_RESPONSE',\n        payload: response\n      });\n      dispatch({\n        type: 'SET_LAST_SAVE_TIME',\n        payload: Date.now()\n      });\n      const isNewResponse = !state.responses.has(response.questionId);\n      if (isNewResponse) {\n        const completedQuestions = state.progress.completedQuestions + 1;\n        dispatch({\n          type: 'UPDATE_PROGRESS',\n          payload: {\n            completedQuestions\n          }\n        });\n      }\n    } catch (error) {\n      console.error('FormContext: Error saving response:', error);\n      dispatch({\n        type: 'SET_ERROR',\n        payload: 'Failed to save response'\n      });\n      throw error;\n    }\n  }, [state.responses, state.progress.completedQuestions]);\n  const navigateToPosition = useCallback(async (categoryIndex, subcategoryIndex, topicIndex, questionIndex) => {\n    const newPosition = {\n      categoryIndex,\n      subcategoryIndex,\n      topicIndex,\n      questionIndex\n    };\n    dispatch({\n      type: 'SET_CURRENT_POSITION',\n      payload: newPosition\n    });\n    if (state.sessionId) {\n      try {\n        await api.updateUserProgress(state.sessionId, {\n          currentCategory: categoryIndex,\n          currentSubcategory: subcategoryIndex,\n          currentTopic: topicIndex,\n          currentQuestion: questionIndex\n        });\n      } catch (error) {\n        console.error('Failed to save navigation progress:', error);\n      }\n    }\n  }, [state.sessionId]);\n  const getCurrentQuestionData = useCallback(() => {\n    const {\n      categoryIndex,\n      subcategoryIndex,\n      topicIndex,\n      questionIndex\n    } = state.currentPosition;\n    if (!state.questionsData[categoryIndex]) return null;\n    const category = state.questionsData[categoryIndex];\n    const subcategory = category.subcategories[subcategoryIndex];\n    const topic = subcategory === null || subcategory === void 0 ? void 0 : subcategory.topics[topicIndex];\n    const question = topic === null || topic === void 0 ? void 0 : topic.questions[questionIndex];\n    if (!question) return null;\n    return {\n      category: category.category,\n      subcategory: subcategory.subcategory,\n      topic: topic.topic,\n      question,\n      questionId: `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`\n    };\n  }, [state.currentPosition, state.questionsData]);\n  const getCurrentQuestion = useCallback(() => {\n    const data = getCurrentQuestionData();\n    return (data === null || data === void 0 ? void 0 : data.question) || null;\n  }, [getCurrentQuestionData]);\n  const navigateToNext = useCallback(async () => {\n    const {\n      categoryIndex,\n      subcategoryIndex,\n      topicIndex,\n      questionIndex\n    } = state.currentPosition;\n    const category = state.questionsData[categoryIndex];\n    if (!category) return;\n    const subcategory = category.subcategories[subcategoryIndex];\n    const topic = subcategory === null || subcategory === void 0 ? void 0 : subcategory.topics[topicIndex];\n    if (!topic) return;\n    let newPosition = {\n      ...state.currentPosition\n    };\n    if (questionIndex < topic.questions.length - 1) {\n      newPosition.questionIndex = questionIndex + 1;\n    } else if (topicIndex < subcategory.topics.length - 1) {\n      newPosition.topicIndex = topicIndex + 1;\n      newPosition.questionIndex = 0;\n    } else if (subcategoryIndex < category.subcategories.length - 1) {\n      newPosition.subcategoryIndex = subcategoryIndex + 1;\n      newPosition.topicIndex = 0;\n      newPosition.questionIndex = 0;\n    } else if (categoryIndex < state.questionsData.length - 1) {\n      newPosition.categoryIndex = categoryIndex + 1;\n      newPosition.subcategoryIndex = 0;\n      newPosition.topicIndex = 0;\n      newPosition.questionIndex = 0;\n    } else {\n      dispatch({\n        type: 'SET_COMPLETED',\n        payload: true\n      });\n      return;\n    }\n    dispatch({\n      type: 'SET_CURRENT_POSITION',\n      payload: newPosition\n    });\n    if (state.sessionId) {\n      try {\n        await api.updateUserProgress(state.sessionId, {\n          currentCategory: newPosition.categoryIndex,\n          currentSubcategory: newPosition.subcategoryIndex,\n          currentTopic: newPosition.topicIndex,\n          currentQuestion: newPosition.questionIndex\n        });\n      } catch (error) {\n        console.error('Failed to save progress:', error);\n      }\n    }\n  }, [state.currentPosition, state.questionsData, state.sessionId]);\n  const navigateToPrevious = useCallback(async () => {\n    const {\n      categoryIndex,\n      subcategoryIndex,\n      topicIndex,\n      questionIndex\n    } = state.currentPosition;\n    let newPosition = {\n      ...state.currentPosition\n    };\n    if (questionIndex > 0) {\n      newPosition.questionIndex = questionIndex - 1;\n    } else if (topicIndex > 0) {\n      const prevTopic = state.questionsData[categoryIndex].subcategories[subcategoryIndex].topics[topicIndex - 1];\n      newPosition.topicIndex = topicIndex - 1;\n      newPosition.questionIndex = prevTopic.questions.length - 1;\n    } else if (subcategoryIndex > 0) {\n      const prevSubcategory = state.questionsData[categoryIndex].subcategories[subcategoryIndex - 1];\n      const lastTopic = prevSubcategory.topics[prevSubcategory.topics.length - 1];\n      newPosition.subcategoryIndex = subcategoryIndex - 1;\n      newPosition.topicIndex = prevSubcategory.topics.length - 1;\n      newPosition.questionIndex = lastTopic.questions.length - 1;\n    } else if (categoryIndex > 0) {\n      const prevCategory = state.questionsData[categoryIndex - 1];\n      const lastSubcategory = prevCategory.subcategories[prevCategory.subcategories.length - 1];\n      const lastTopic = lastSubcategory.topics[lastSubcategory.topics.length - 1];\n      newPosition.categoryIndex = categoryIndex - 1;\n      newPosition.subcategoryIndex = prevCategory.subcategories.length - 1;\n      newPosition.topicIndex = lastSubcategory.topics.length - 1;\n      newPosition.questionIndex = lastTopic.questions.length - 1;\n    }\n    dispatch({\n      type: 'SET_CURRENT_POSITION',\n      payload: newPosition\n    });\n    if (state.sessionId) {\n      try {\n        await api.updateUserProgress(state.sessionId, {\n          currentCategory: newPosition.categoryIndex,\n          currentSubcategory: newPosition.subcategoryIndex,\n          currentTopic: newPosition.topicIndex,\n          currentQuestion: newPosition.questionIndex\n        });\n      } catch (error) {\n        console.error('Failed to save progress:', error);\n      }\n    }\n  }, [state.currentPosition, state.questionsData, state.sessionId]);\n  const calculateProgress = useCallback(() => {\n    const totalQuestions = state.progress.totalQuestions;\n    const completedQuestions = state.responses.size;\n    return totalQuestions > 0 ? completedQuestions / totalQuestions * 100 : 0;\n  }, [state.progress.totalQuestions, state.responses.size]);\n  const getTotalQuestionsInCurrentTopic = useCallback(() => {\n    var _state$questionsData$, _state$questionsData$2;\n    const {\n      categoryIndex,\n      subcategoryIndex,\n      topicIndex\n    } = state.currentPosition;\n    const topic = (_state$questionsData$ = state.questionsData[categoryIndex]) === null || _state$questionsData$ === void 0 ? void 0 : (_state$questionsData$2 = _state$questionsData$.subcategories[subcategoryIndex]) === null || _state$questionsData$2 === void 0 ? void 0 : _state$questionsData$2.topics[topicIndex];\n    return (topic === null || topic === void 0 ? void 0 : topic.questions.length) || 0;\n  }, [state.currentPosition, state.questionsData]);\n  const getCompletedQuestionsInCurrentTopic = useCallback(() => {\n    var _state$questionsData$3, _state$questionsData$4;\n    const {\n      categoryIndex,\n      subcategoryIndex,\n      topicIndex\n    } = state.currentPosition;\n    let completed = 0;\n    const topic = (_state$questionsData$3 = state.questionsData[categoryIndex]) === null || _state$questionsData$3 === void 0 ? void 0 : (_state$questionsData$4 = _state$questionsData$3.subcategories[subcategoryIndex]) === null || _state$questionsData$4 === void 0 ? void 0 : _state$questionsData$4.topics[topicIndex];\n    if (!topic) return 0;\n    topic.questions.forEach((_, questionIndex) => {\n      const questionId = `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\n      if (state.responses.has(questionId)) {\n        completed++;\n      }\n    });\n    return completed;\n  }, [state.currentPosition, state.questionsData, state.responses]);\n\n  // FIXED: Reset session function\n  const resetSession = useCallback(() => {\n    localStorage.removeItem('culturalSurveySessionId');\n    localStorage.removeItem('culturalSurveyStartTime');\n    if (timerInterval) {\n      clearInterval(timerInterval);\n      setTimerInterval(null);\n    }\n    surveyStartTimeRef.current = 0; // Reset the ref\n    dispatch({\n      type: 'RESET_FORM'\n    });\n  }, [timerInterval]);\n  const value = {\n    state,\n    dispatch,\n    createUserSession,\n    saveResponse,\n    navigateToNext,\n    navigateToPrevious,\n    calculateProgress,\n    getCurrentQuestion,\n    getCurrentQuestionData,\n    getTotalQuestionsInCurrentTopic,\n    getCompletedQuestionsInCurrentTopic,\n    loadUserSession,\n    navigateToPosition,\n    resetSession,\n    startSurveyTimer,\n    formatTimeRemaining\n  };\n  return /*#__PURE__*/_jsxDEV(FormContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 704,\n    columnNumber: 5\n  }, this);\n}\n_s(FormProvider, \"nHQMB4tybj4rBKrJJedVycbtg94=\");\n_c = FormProvider;\nexport function useForm() {\n  _s2();\n  const context = useContext(FormContext);\n  if (context === undefined) {\n    throw new Error('useForm must be used within a FormProvider');\n  }\n  return context;\n}\n_s2(useForm, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"FormProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","useCallback","useRef","useState","loadQuestionsData","api","jsxDEV","_jsxDEV","SURVEY_TIME_LIMIT","WARNING_TIME_REMAINING","CRITICAL_TIME_REMAINING","initialState","sessionId","userInfo","currentPosition","categoryIndex","subcategoryIndex","topicIndex","questionIndex","responses","Map","progress","currentCategory","currentSubcategory","currentTopic","currentQuestion","completedQuestions","totalQuestions","completedTopics","attentionChecksPassed","attentionChecksFailed","isLoading","error","questionsData","startTime","lastSaveTime","isCompleted","surveyStartTime","surveyTimeLimit","surveyTimeRemaining","showTimeWarning","showTimeCritical","surveyExpired","formReducer","state","action","type","payload","newResponses","set","questionId","responseMap","forEach","response","Date","now","timeRemaining","showWarning","showCritical","FormContext","undefined","FormProvider","children","_s","dispatch","hasLoadedQuestions","isLoadingSession","timerInterval","setTimerInterval","surveyStartTimeRef","current","loadData","console","log","data","length","getTotalQuestions","reduce","total","category","subcategories","subTotal","subcategory","topics","topicTotal","topic","questions","completeExpiredSurvey","completeUser","startSurveyTimer","toISOString","clearInterval","interval","setInterval","elapsed","remaining","Math","max","floor","resumeSurveyTimer","formatTimeRemaining","milliseconds","totalSeconds","minutes","seconds","toString","padStart","createUserSession","createUser","localStorage","setItem","loadUserSession","user","getUser","getUserResponses","updatedProgress","nextPosition","findNextUnansweredQuestion","savedStartTime","getItem","parseInt","answeredQuestions","Set","map","r","has","lastCategory","lastSubcategory","lastTopic","saveResponse","isNewResponse","navigateToPosition","newPosition","updateUserProgress","getCurrentQuestionData","question","getCurrentQuestion","navigateToNext","navigateToPrevious","prevTopic","prevSubcategory","prevCategory","calculateProgress","size","getTotalQuestionsInCurrentTopic","_state$questionsData$","_state$questionsData$2","getCompletedQuestionsInCurrentTopic","_state$questionsData$3","_state$questionsData$4","completed","_","resetSession","removeItem","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useForm","_s2","context","Error","$RefreshReg$"],"sources":["C:/Users/sangm/OneDrive - Brock University/CommonsenseForm/client/src/context/FormContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, ReactNode, useCallback, useRef, useState } from 'react';\r\nimport { FormState, UserInfo, QuestionResponse, Category, Progress } from '../types/index.ts';\r\nimport { loadQuestionsData } from '../utils/helpers.ts';\r\nimport * as api from '../services/api.ts';\r\n\r\n// Timer constants\r\nconst SURVEY_TIME_LIMIT = 15 * 60 * 1000; // 15 minutes in milliseconds\r\nconst WARNING_TIME_REMAINING = 2 * 60 * 1000; // Show warning at 2 minutes remaining\r\nconst CRITICAL_TIME_REMAINING = 30 * 1000; // Show critical warning at 30 seconds\r\n\r\ntype FormAction =\r\n  | { type: 'SET_LOADING'; payload: boolean }\r\n  | { type: 'SET_ERROR'; payload: string | null }\r\n  | { type: 'SET_SESSION_ID'; payload: string }\r\n  | { type: 'SET_USER_INFO'; payload: UserInfo }\r\n  | { type: 'SET_QUESTIONS_DATA'; payload: Category[] }\r\n  | { type: 'SET_CURRENT_POSITION'; payload: { categoryIndex: number; subcategoryIndex: number; topicIndex: number; questionIndex: number } }\r\n  | { type: 'ADD_RESPONSE'; payload: QuestionResponse }\r\n  | { type: 'UPDATE_PROGRESS'; payload: Partial<Progress> }\r\n  | { type: 'SET_RESPONSES'; payload: QuestionResponse[] }\r\n  | { type: 'SET_START_TIME'; payload: number }\r\n  | { type: 'SET_LAST_SAVE_TIME'; payload: number }\r\n  | { type: 'SET_COMPLETED'; payload: boolean }\r\n  | { type: 'RESET_FORM' }\r\n  // Timer actions\r\n  | { type: 'START_SURVEY_TIMER' }\r\n  | { type: 'UPDATE_TIMER'; payload: { timeRemaining: number; showWarning: boolean; showCritical: boolean } }\r\n  | { type: 'EXPIRE_SURVEY' };\r\n\r\nconst initialState: FormState = {\r\n  sessionId: null,\r\n  userInfo: null,\r\n  currentPosition: {\r\n    categoryIndex: 0,\r\n    subcategoryIndex: 0,\r\n    topicIndex: 0,\r\n    questionIndex: 0\r\n  },\r\n  responses: new Map(),\r\n  progress: {\r\n    currentCategory: 0,\r\n    currentSubcategory: 0,\r\n    currentTopic: 0,\r\n    currentQuestion: 0,\r\n    completedQuestions: 0,\r\n    totalQuestions: 0,\r\n    completedTopics: [],\r\n    attentionChecksPassed: 0,\r\n    attentionChecksFailed: 0\r\n  },\r\n  isLoading: false,\r\n  error: null,\r\n  questionsData: [],\r\n  startTime: 0,\r\n  lastSaveTime: 0,\r\n  isCompleted: false,\r\n  // Timer state\r\n  surveyStartTime: 0,\r\n  surveyTimeLimit: SURVEY_TIME_LIMIT,\r\n  surveyTimeRemaining: SURVEY_TIME_LIMIT,\r\n  showTimeWarning: false,\r\n  showTimeCritical: false,\r\n  surveyExpired: false\r\n};\r\n\r\nfunction formReducer(state: FormState, action: FormAction): FormState {\r\n  switch (action.type) {\r\n    case 'SET_LOADING':\r\n      return { ...state, isLoading: action.payload };\r\n    case 'SET_ERROR':\r\n      return { ...state, error: action.payload };\r\n    case 'SET_SESSION_ID':\r\n      return { ...state, sessionId: action.payload };\r\n    case 'SET_USER_INFO':\r\n      return { ...state, userInfo: action.payload };\r\n    case 'SET_QUESTIONS_DATA':\r\n      return { ...state, questionsData: action.payload };\r\n    case 'SET_CURRENT_POSITION':\r\n      return { ...state, currentPosition: action.payload };\r\n    case 'ADD_RESPONSE':\r\n      const newResponses = new Map(state.responses);\r\n      newResponses.set(action.payload.questionId, action.payload);\r\n      return { ...state, responses: newResponses };\r\n    case 'UPDATE_PROGRESS':\r\n      return { \r\n        ...state, \r\n        progress: { ...state.progress, ...action.payload }\r\n      };\r\n    case 'SET_RESPONSES':\r\n      const responseMap = new Map();\r\n      action.payload.forEach(response => {\r\n        responseMap.set(response.questionId, response);\r\n      });\r\n      return { ...state, responses: responseMap };\r\n    case 'SET_START_TIME':\r\n      return { ...state, startTime: action.payload };\r\n    case 'SET_LAST_SAVE_TIME':\r\n      return { ...state, lastSaveTime: action.payload };\r\n    case 'SET_COMPLETED':\r\n      return { ...state, isCompleted: action.payload };\r\n    case 'RESET_FORM':\r\n      return { ...initialState, questionsData: state.questionsData };\r\n    // Timer cases\r\n    case 'START_SURVEY_TIMER':\r\n      return {\r\n        ...state,\r\n        surveyStartTime: Date.now(),\r\n        surveyTimeRemaining: state.surveyTimeLimit,\r\n        showTimeWarning: false,\r\n        showTimeCritical: false,\r\n        surveyExpired: false\r\n      };\r\n    case 'UPDATE_TIMER':\r\n      return {\r\n        ...state,\r\n        surveyTimeRemaining: action.payload.timeRemaining,\r\n        showTimeWarning: action.payload.showWarning,\r\n        showTimeCritical: action.payload.showCritical\r\n      };\r\n    case 'EXPIRE_SURVEY':\r\n      return {\r\n        ...state,\r\n        surveyExpired: true,\r\n        surveyTimeRemaining: 0,\r\n        isCompleted: true\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Updated interface\r\ninterface FormContextType {\r\n  state: FormState;\r\n  dispatch: React.Dispatch<FormAction>;\r\n  createUserSession: (userInfo: UserInfo) => Promise<void>;\r\n  saveResponse: (response: QuestionResponse) => Promise<void>;\r\n  navigateToNext: () => void;\r\n  navigateToPrevious: () => void;\r\n  calculateProgress: () => number;\r\n  getCurrentQuestion: () => string | null;\r\n  getCurrentQuestionData: () => {\r\n    category: string;\r\n    subcategory: string;\r\n    topic: string;\r\n    question: string;\r\n    questionId: string;\r\n  } | null;\r\n  getTotalQuestionsInCurrentTopic: () => number;\r\n  getCompletedQuestionsInCurrentTopic: () => number;\r\n  loadUserSession: (sessionId: string) => Promise<void>;\r\n  navigateToPosition: (categoryIndex: number, subcategoryIndex: number, topicIndex: number, questionIndex: number) => Promise<void>;\r\n  resetSession: () => void;\r\n  // Timer functions\r\n  startSurveyTimer: () => void;\r\n  formatTimeRemaining: (milliseconds: number) => string;\r\n}\r\n\r\nconst FormContext = createContext<FormContextType | undefined>(undefined);\r\n\r\nexport function FormProvider({ children }: { children: ReactNode }) {\r\n  const [state, dispatch] = useReducer(formReducer, initialState);\r\n  const hasLoadedQuestions = useRef(false);\r\n  const isLoadingSession = useRef(false);\r\n  const [timerInterval, setTimerInterval] = useState<ReturnType<typeof setInterval> | null>(null);\r\n  const surveyStartTimeRef = useRef<number>(0); // Add this ref to track start time\r\n\r\n\r\n  // Load questions data only once\r\n  useEffect(() => {\r\n    if (hasLoadedQuestions.current) return;\r\n    \r\n    const loadData = async () => {\r\n      try {\r\n        hasLoadedQuestions.current = true;\r\n        dispatch({ type: 'SET_LOADING', payload: true });\r\n        dispatch({ type: 'SET_ERROR', payload: null });\r\n        \r\n        console.log('FormContext: Loading questions data...');\r\n        const data = await loadQuestionsData();\r\n        console.log('FormContext: Questions loaded:', data.length, 'categories');\r\n        \r\n        dispatch({ type: 'SET_QUESTIONS_DATA', payload: data });\r\n        \r\n        const totalQuestions = getTotalQuestions(data);\r\n        console.log('FormContext: Total questions calculated:', totalQuestions);\r\n        \r\n        dispatch({ type: 'UPDATE_PROGRESS', payload: { totalQuestions } });\r\n        \r\n      } catch (error) {\r\n        console.error('FormContext: Error loading questions:', error);\r\n        dispatch({ type: 'SET_ERROR', payload: 'Failed to load questions data. Please refresh the page.' });\r\n        hasLoadedQuestions.current = false;\r\n      } finally {\r\n        dispatch({ type: 'SET_LOADING', payload: false });\r\n      }\r\n    };\r\n\r\n    loadData();\r\n  }, []);\r\n\r\n  // Calculate total questions\r\n  const getTotalQuestions = (questionsData: Category[]): number => {\r\n    return questionsData.reduce((total, category) => {\r\n      return total + category.subcategories.reduce((subTotal, subcategory) => {\r\n        return subTotal + subcategory.topics.reduce((topicTotal, topic) => {\r\n          return topicTotal + topic.questions.length;\r\n        }, 0);\r\n      }, 0);\r\n    }, 0);\r\n  };\r\n\r\n  // Auto-complete survey when time expires\r\n  const completeExpiredSurvey = useCallback(async () => {\r\n    if (state.sessionId) {\r\n      try {\r\n        console.log('Survey time expired, auto-completing...');\r\n        await api.completeUser(state.sessionId);\r\n        dispatch({ type: 'SET_COMPLETED', payload: true });\r\n      } catch (error) {\r\n        console.error('Error auto-completing expired survey:', error);\r\n      }\r\n    }\r\n  }, [state.sessionId]);\r\n  // FIXED: Start timer function\r\n  const startSurveyTimer = useCallback(() => {\r\n    const startTime = Date.now();\r\n    console.log('Starting survey timer at:', new Date(startTime).toISOString());\r\n    \r\n    // Update both state and ref\r\n    dispatch({ type: 'START_SURVEY_TIMER' });\r\n    surveyStartTimeRef.current = startTime;\r\n    \r\n    // Clear any existing timer\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n    }\r\n\r\n    // Start new timer using the ref value\r\n    const interval = setInterval(() => {\r\n      const now = Date.now();\r\n      const elapsed = now - surveyStartTimeRef.current; // Use ref instead of state\r\n      const remaining = Math.max(0, SURVEY_TIME_LIMIT - elapsed);\r\n      \r\n      console.log('Timer update:', {\r\n        elapsed: Math.floor(elapsed / 1000) + 's',\r\n        remaining: Math.floor(remaining / 1000) + 's'\r\n      });\r\n      \r\n      const showWarning = remaining <= WARNING_TIME_REMAINING && remaining > CRITICAL_TIME_REMAINING;\r\n      const showCritical = remaining <= CRITICAL_TIME_REMAINING && remaining > 0;\r\n      \r\n      if (remaining <= 0) {\r\n        console.log('Timer expired!');\r\n        dispatch({ type: 'EXPIRE_SURVEY' });\r\n        clearInterval(interval);\r\n        setTimerInterval(null);\r\n        completeExpiredSurvey();\r\n      } else {\r\n        dispatch({ \r\n          type: 'UPDATE_TIMER', \r\n          payload: { \r\n            timeRemaining: remaining, \r\n            showWarning, \r\n            showCritical \r\n          } \r\n        });\r\n      }\r\n    }, 1000); // Update every second\r\n\r\n    setTimerInterval(interval);\r\n  }, [timerInterval, completeExpiredSurvey]);\r\n\r\n  // FIXED: Resume timer function\r\n  const resumeSurveyTimer = useCallback((startTime: number) => {\r\n    console.log('Resuming survey timer from:', new Date(startTime).toISOString());\r\n    const now = Date.now();\r\n    const elapsed = now - startTime;\r\n    const remaining = Math.max(0, SURVEY_TIME_LIMIT - elapsed);\r\n    \r\n    console.log('Resume timer:', {\r\n      startTime: new Date(startTime).toISOString(),\r\n      elapsed: Math.floor(elapsed / 1000) + 's',\r\n      remaining: Math.floor(remaining / 1000) + 's'\r\n    });\r\n    \r\n    if (remaining <= 0) {\r\n      console.log('Survey already expired on resume');\r\n      dispatch({ type: 'EXPIRE_SURVEY' });\r\n      completeExpiredSurvey();\r\n      return;\r\n    }\r\n\r\n    // Set the ref to the original start time\r\n    surveyStartTimeRef.current = startTime;\r\n\r\n    // Update state\r\n    dispatch({\r\n      type: 'UPDATE_TIMER',\r\n      payload: {\r\n        timeRemaining: remaining,\r\n        showWarning: remaining <= WARNING_TIME_REMAINING,\r\n        showCritical: remaining <= CRITICAL_TIME_REMAINING\r\n      }\r\n    });\r\n\r\n    // Clear any existing timer\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n    }\r\n\r\n    // Start timer with correct start time\r\n    const interval = setInterval(() => {\r\n      const now = Date.now();\r\n      const elapsed = now - surveyStartTimeRef.current; // Use the original start time\r\n      const remaining = Math.max(0, SURVEY_TIME_LIMIT - elapsed);\r\n      \r\n      const showWarning = remaining <= WARNING_TIME_REMAINING && remaining > CRITICAL_TIME_REMAINING;\r\n      const showCritical = remaining <= CRITICAL_TIME_REMAINING && remaining > 0;\r\n      \r\n      if (remaining <= 0) {\r\n        dispatch({ type: 'EXPIRE_SURVEY' });\r\n        clearInterval(interval);\r\n        setTimerInterval(null);\r\n        completeExpiredSurvey();\r\n      } else {\r\n        dispatch({ \r\n          type: 'UPDATE_TIMER', \r\n          payload: { \r\n            timeRemaining: remaining, \r\n            showWarning, \r\n            showCritical \r\n          } \r\n        });\r\n      }\r\n    }, 1000);\r\n\r\n    setTimerInterval(interval);\r\n  }, [timerInterval, completeExpiredSurvey]);\r\n\r\n  // Clean up timer on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (timerInterval) {\r\n        clearInterval(timerInterval);\r\n      }\r\n    };\r\n  }, [timerInterval]);\r\n\r\n  // FIXED: Format time function\r\n  const formatTimeRemaining = useCallback((milliseconds: number): string => {\r\n    const totalSeconds = Math.max(0, Math.floor(milliseconds / 1000));\r\n    const minutes = Math.floor(totalSeconds / 60);\r\n    const seconds = totalSeconds % 60;\r\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\r\n  }, []);\r\n\r\n  // FIXED: Create user session\r\n  const createUserSession = useCallback(async (userInfo: UserInfo) => {\r\n    try {\r\n      dispatch({ type: 'SET_LOADING', payload: true });\r\n      const response = await api.createUser(userInfo);\r\n      dispatch({ type: 'SET_SESSION_ID', payload: response.sessionId });\r\n      dispatch({ type: 'SET_USER_INFO', payload: userInfo });\r\n      \r\n      const startTime = Date.now();\r\n      dispatch({ type: 'SET_START_TIME', payload: startTime });\r\n      \r\n      // Store session ID and start time in localStorage\r\n      localStorage.setItem('culturalSurveySessionId', response.sessionId);\r\n      localStorage.setItem('culturalSurveyStartTime', startTime.toString());\r\n      \r\n      // Start the survey timer\r\n      console.log('Creating user session and starting timer');\r\n      startSurveyTimer();\r\n      \r\n    } catch (error) {\r\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to create user session' });\r\n      throw error;\r\n    } finally {\r\n      dispatch({ type: 'SET_LOADING', payload: false });\r\n    }\r\n  }, [startSurveyTimer]);\r\n\r\n  const loadUserSession = useCallback(async (sessionId: string) => {\r\n    if (isLoadingSession.current) return;\r\n    \r\n    try {\r\n      isLoadingSession.current = true;\r\n      dispatch({ type: 'SET_LOADING', payload: true });\r\n      \r\n      console.log('FormContext: Loading user session...');\r\n      const user = await api.getUser(sessionId);\r\n      \r\n      dispatch({ type: 'SET_SESSION_ID', payload: sessionId });\r\n      dispatch({ type: 'SET_USER_INFO', payload: user.userInfo });\r\n      dispatch({ type: 'SET_COMPLETED', payload: user.isCompleted });\r\n      \r\n      // Load responses\r\n      console.log('FormContext: Loading user responses...');\r\n      const responses = await api.getUserResponses(sessionId);\r\n      console.log('FormContext: Responses loaded:', responses.length);\r\n      \r\n      dispatch({ type: 'SET_RESPONSES', payload: responses });\r\n      \r\n      // Recalculate total questions from current data\r\n      const totalQuestions = getTotalQuestions(state.questionsData);\r\n      \r\n      const updatedProgress = {\r\n        ...user.progress,\r\n        totalQuestions,\r\n        completedQuestions: responses.length\r\n      };\r\n      \r\n      dispatch({ type: 'UPDATE_PROGRESS', payload: updatedProgress });\r\n      \r\n      // Find the correct starting position\r\n      const nextPosition = findNextUnansweredQuestion(responses, state.questionsData);\r\n      console.log('FormContext: Setting position to:', nextPosition);\r\n      \r\n      dispatch({ type: 'SET_CURRENT_POSITION', payload: nextPosition });\r\n      \r\n      // Resume timer if not completed\r\n      if (!user.isCompleted) {\r\n        const savedStartTime = localStorage.getItem('culturalSurveyStartTime');\r\n        if (savedStartTime) {\r\n          resumeSurveyTimer(parseInt(savedStartTime));\r\n        } else {\r\n          // If no start time found, start fresh timer\r\n          localStorage.setItem('culturalSurveyStartTime', Date.now().toString());\r\n          startSurveyTimer();\r\n        }\r\n      }\r\n      \r\n    } catch (error) {\r\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to load user session' });\r\n      throw error;\r\n    } finally {\r\n      dispatch({ type: 'SET_LOADING', payload: false });\r\n      isLoadingSession.current = false;\r\n    }\r\n  }, [state.questionsData, resumeSurveyTimer, startSurveyTimer]);\r\n\r\n  const findNextUnansweredQuestion = useCallback((responses: QuestionResponse[], questionsData: Category[]) => {\r\n    const answeredQuestions = new Set(responses.map(r => r.questionId));\r\n    \r\n    for (let categoryIndex = 0; categoryIndex < questionsData.length; categoryIndex++) {\r\n      const category = questionsData[categoryIndex];\r\n      \r\n      for (let subcategoryIndex = 0; subcategoryIndex < category.subcategories.length; subcategoryIndex++) {\r\n        const subcategory = category.subcategories[subcategoryIndex];\r\n        \r\n        for (let topicIndex = 0; topicIndex < subcategory.topics.length; topicIndex++) {\r\n          const topic = subcategory.topics[topicIndex];\r\n          \r\n          for (let questionIndex = 0; questionIndex < topic.questions.length; questionIndex++) {\r\n            const questionId = `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\r\n            \r\n            if (!answeredQuestions.has(questionId)) {\r\n              return {\r\n                categoryIndex,\r\n                subcategoryIndex,\r\n                topicIndex,\r\n                questionIndex\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    if (questionsData.length > 0) {\r\n      const lastCategory = questionsData[questionsData.length - 1];\r\n      const lastSubcategory = lastCategory.subcategories[lastCategory.subcategories.length - 1];\r\n      const lastTopic = lastSubcategory.topics[lastSubcategory.topics.length - 1];\r\n      \r\n      return {\r\n        categoryIndex: questionsData.length - 1,\r\n        subcategoryIndex: lastCategory.subcategories.length - 1,\r\n        topicIndex: lastSubcategory.topics.length - 1,\r\n        questionIndex: lastTopic.questions.length - 1\r\n      };\r\n    }\r\n    \r\n    return { categoryIndex: 0, subcategoryIndex: 0, topicIndex: 0, questionIndex: 0 };\r\n  }, []);\r\n\r\n  const saveResponse = useCallback(async (response: QuestionResponse) => {\r\n    try {\r\n      console.log('FormContext: Saving response:', response);\r\n      await api.saveResponse(response);\r\n      dispatch({ type: 'ADD_RESPONSE', payload: response });\r\n      dispatch({ type: 'SET_LAST_SAVE_TIME', payload: Date.now() });\r\n      \r\n      const isNewResponse = !state.responses.has(response.questionId);\r\n      if (isNewResponse) {\r\n        const completedQuestions = state.progress.completedQuestions + 1;\r\n        dispatch({ type: 'UPDATE_PROGRESS', payload: { completedQuestions } });\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('FormContext: Error saving response:', error);\r\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to save response' });\r\n      throw error;\r\n    }\r\n  }, [state.responses, state.progress.completedQuestions]);\r\n\r\n  const navigateToPosition = useCallback(async (categoryIndex: number, subcategoryIndex: number, topicIndex: number, questionIndex: number) => {\r\n    const newPosition = { categoryIndex, subcategoryIndex, topicIndex, questionIndex };\r\n    dispatch({ type: 'SET_CURRENT_POSITION', payload: newPosition });\r\n\r\n    if (state.sessionId) {\r\n      try {\r\n        await api.updateUserProgress(state.sessionId, {\r\n          currentCategory: categoryIndex,\r\n          currentSubcategory: subcategoryIndex,\r\n          currentTopic: topicIndex,\r\n          currentQuestion: questionIndex\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to save navigation progress:', error);\r\n      }\r\n    }\r\n  }, [state.sessionId]);\r\n\r\n  const getCurrentQuestionData = useCallback(() => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex, questionIndex } = state.currentPosition;\r\n    \r\n    if (!state.questionsData[categoryIndex]) return null;\r\n    \r\n    const category = state.questionsData[categoryIndex];\r\n    const subcategory = category.subcategories[subcategoryIndex];\r\n    const topic = subcategory?.topics[topicIndex];\r\n    const question = topic?.questions[questionIndex];\r\n    \r\n    if (!question) return null;\r\n    \r\n    return {\r\n      category: category.category,\r\n      subcategory: subcategory.subcategory,\r\n      topic: topic.topic,\r\n      question,\r\n      questionId: `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`\r\n    };\r\n  }, [state.currentPosition, state.questionsData]);\r\n\r\n  const getCurrentQuestion = useCallback(() => {\r\n    const data = getCurrentQuestionData();\r\n    return data?.question || null;\r\n  }, [getCurrentQuestionData]);\r\n\r\n  const navigateToNext = useCallback(async () => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex, questionIndex } = state.currentPosition;\r\n    const category = state.questionsData[categoryIndex];\r\n    \r\n    if (!category) return;\r\n    \r\n    const subcategory = category.subcategories[subcategoryIndex];\r\n    const topic = subcategory?.topics[topicIndex];\r\n    \r\n    if (!topic) return;\r\n\r\n    let newPosition = { ...state.currentPosition };\r\n\r\n    if (questionIndex < topic.questions.length - 1) {\r\n      newPosition.questionIndex = questionIndex + 1;\r\n    } else if (topicIndex < subcategory.topics.length - 1) {\r\n      newPosition.topicIndex = topicIndex + 1;\r\n      newPosition.questionIndex = 0;\r\n    } else if (subcategoryIndex < category.subcategories.length - 1) {\r\n      newPosition.subcategoryIndex = subcategoryIndex + 1;\r\n      newPosition.topicIndex = 0;\r\n      newPosition.questionIndex = 0;\r\n    } else if (categoryIndex < state.questionsData.length - 1) {\r\n      newPosition.categoryIndex = categoryIndex + 1;\r\n      newPosition.subcategoryIndex = 0;\r\n      newPosition.topicIndex = 0;\r\n      newPosition.questionIndex = 0;\r\n    } else {\r\n      dispatch({ type: 'SET_COMPLETED', payload: true });\r\n      return;\r\n    }\r\n\r\n    dispatch({ type: 'SET_CURRENT_POSITION', payload: newPosition });\r\n\r\n    if (state.sessionId) {\r\n      try {\r\n        await api.updateUserProgress(state.sessionId, {\r\n          currentCategory: newPosition.categoryIndex,\r\n          currentSubcategory: newPosition.subcategoryIndex,\r\n          currentTopic: newPosition.topicIndex,\r\n          currentQuestion: newPosition.questionIndex\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to save progress:', error);\r\n      }\r\n    }\r\n  }, [state.currentPosition, state.questionsData, state.sessionId]);\r\n\r\n  const navigateToPrevious = useCallback(async () => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex, questionIndex } = state.currentPosition;\r\n    \r\n    let newPosition = { ...state.currentPosition };\r\n\r\n    if (questionIndex > 0) {\r\n      newPosition.questionIndex = questionIndex - 1;\r\n    } else if (topicIndex > 0) {\r\n      const prevTopic = state.questionsData[categoryIndex].subcategories[subcategoryIndex].topics[topicIndex - 1];\r\n      newPosition.topicIndex = topicIndex - 1;\r\n      newPosition.questionIndex = prevTopic.questions.length - 1;\r\n    } else if (subcategoryIndex > 0) {\r\n      const prevSubcategory = state.questionsData[categoryIndex].subcategories[subcategoryIndex - 1];\r\n      const lastTopic = prevSubcategory.topics[prevSubcategory.topics.length - 1];\r\n      newPosition.subcategoryIndex = subcategoryIndex - 1;\r\n      newPosition.topicIndex = prevSubcategory.topics.length - 1;\r\n      newPosition.questionIndex = lastTopic.questions.length - 1;\r\n    } else if (categoryIndex > 0) {\r\n      const prevCategory = state.questionsData[categoryIndex - 1];\r\n      const lastSubcategory = prevCategory.subcategories[prevCategory.subcategories.length - 1];\r\n      const lastTopic = lastSubcategory.topics[lastSubcategory.topics.length - 1];\r\n      newPosition.categoryIndex = categoryIndex - 1;\r\n      newPosition.subcategoryIndex = prevCategory.subcategories.length - 1;\r\n      newPosition.topicIndex = lastSubcategory.topics.length - 1;\r\n      newPosition.questionIndex = lastTopic.questions.length - 1;\r\n    }\r\n\r\n    dispatch({ type: 'SET_CURRENT_POSITION', payload: newPosition });\r\n\r\n    if (state.sessionId) {\r\n      try {\r\n        await api.updateUserProgress(state.sessionId, {\r\n          currentCategory: newPosition.categoryIndex,\r\n          currentSubcategory: newPosition.subcategoryIndex,\r\n          currentTopic: newPosition.topicIndex,\r\n          currentQuestion: newPosition.questionIndex\r\n        });\r\n      } catch (error) {\r\n        console.error('Failed to save progress:', error);\r\n      }\r\n    }\r\n  }, [state.currentPosition, state.questionsData, state.sessionId]);\r\n\r\n  const calculateProgress = useCallback(() => {\r\n    const totalQuestions = state.progress.totalQuestions;\r\n    const completedQuestions = state.responses.size;\r\n    return totalQuestions > 0 ? (completedQuestions / totalQuestions) * 100 : 0;\r\n  }, [state.progress.totalQuestions, state.responses.size]);\r\n\r\n  const getTotalQuestionsInCurrentTopic = useCallback(() => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex } = state.currentPosition;\r\n    const topic = state.questionsData[categoryIndex]?.subcategories[subcategoryIndex]?.topics[topicIndex];\r\n    return topic?.questions.length || 0;\r\n  }, [state.currentPosition, state.questionsData]);\r\n\r\n  const getCompletedQuestionsInCurrentTopic = useCallback(() => {\r\n    const { categoryIndex, subcategoryIndex, topicIndex } = state.currentPosition;\r\n    let completed = 0;\r\n    \r\n    const topic = state.questionsData[categoryIndex]?.subcategories[subcategoryIndex]?.topics[topicIndex];\r\n    if (!topic) return 0;\r\n    \r\n    topic.questions.forEach((_, questionIndex) => {\r\n      const questionId = `${categoryIndex}-${subcategoryIndex}-${topicIndex}-${questionIndex}`;\r\n      if (state.responses.has(questionId)) {\r\n        completed++;\r\n      }\r\n    });\r\n    \r\n    return completed;\r\n  }, [state.currentPosition, state.questionsData, state.responses]);\r\n\r\n  // FIXED: Reset session function\r\n  const resetSession = useCallback(() => {\r\n    localStorage.removeItem('culturalSurveySessionId');\r\n    localStorage.removeItem('culturalSurveyStartTime');\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n      setTimerInterval(null);\r\n    }\r\n    surveyStartTimeRef.current = 0; // Reset the ref\r\n    dispatch({ type: 'RESET_FORM' });\r\n  }, [timerInterval]);\r\n  \r\n  const value: FormContextType = {\r\n    state,\r\n    dispatch,\r\n    createUserSession,\r\n    saveResponse,\r\n    navigateToNext,\r\n    navigateToPrevious,\r\n    calculateProgress,\r\n    getCurrentQuestion,\r\n    getCurrentQuestionData,\r\n    getTotalQuestionsInCurrentTopic,\r\n    getCompletedQuestionsInCurrentTopic,\r\n    loadUserSession,\r\n    navigateToPosition,\r\n    resetSession,\r\n    startSurveyTimer,\r\n    formatTimeRemaining\r\n  };\r\n\r\n  return (\r\n    <FormContext.Provider value={value}>\r\n      {children}\r\n    </FormContext.Provider>\r\n  );\r\n}\r\n\r\nexport function useForm() {\r\n  const context = useContext(FormContext);\r\n  if (context === undefined) {\r\n    throw new Error('useForm must be used within a FormProvider');\r\n  }\r\n  return context;\r\n}"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,UAAU,EAAEC,SAAS,EAAaC,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEzH,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD,OAAO,KAAKC,GAAG,MAAM,oBAAoB;;AAEzC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,iBAAiB,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AAC1C,MAAMC,sBAAsB,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;AAC9C,MAAMC,uBAAuB,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;;AAqB3C,MAAMC,YAAuB,GAAG;EAC9BC,SAAS,EAAE,IAAI;EACfC,QAAQ,EAAE,IAAI;EACdC,eAAe,EAAE;IACfC,aAAa,EAAE,CAAC;IAChBC,gBAAgB,EAAE,CAAC;IACnBC,UAAU,EAAE,CAAC;IACbC,aAAa,EAAE;EACjB,CAAC;EACDC,SAAS,EAAE,IAAIC,GAAG,CAAC,CAAC;EACpBC,QAAQ,EAAE;IACRC,eAAe,EAAE,CAAC;IAClBC,kBAAkB,EAAE,CAAC;IACrBC,YAAY,EAAE,CAAC;IACfC,eAAe,EAAE,CAAC;IAClBC,kBAAkB,EAAE,CAAC;IACrBC,cAAc,EAAE,CAAC;IACjBC,eAAe,EAAE,EAAE;IACnBC,qBAAqB,EAAE,CAAC;IACxBC,qBAAqB,EAAE;EACzB,CAAC;EACDC,SAAS,EAAE,KAAK;EAChBC,KAAK,EAAE,IAAI;EACXC,aAAa,EAAE,EAAE;EACjBC,SAAS,EAAE,CAAC;EACZC,YAAY,EAAE,CAAC;EACfC,WAAW,EAAE,KAAK;EAClB;EACAC,eAAe,EAAE,CAAC;EAClBC,eAAe,EAAE9B,iBAAiB;EAClC+B,mBAAmB,EAAE/B,iBAAiB;EACtCgC,eAAe,EAAE,KAAK;EACtBC,gBAAgB,EAAE,KAAK;EACvBC,aAAa,EAAE;AACjB,CAAC;AAED,SAASC,WAAWA,CAACC,KAAgB,EAAEC,MAAkB,EAAa;EACpE,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAK,aAAa;MAChB,OAAO;QAAE,GAAGF,KAAK;QAAEb,SAAS,EAAEc,MAAM,CAACE;MAAQ,CAAC;IAChD,KAAK,WAAW;MACd,OAAO;QAAE,GAAGH,KAAK;QAAEZ,KAAK,EAAEa,MAAM,CAACE;MAAQ,CAAC;IAC5C,KAAK,gBAAgB;MACnB,OAAO;QAAE,GAAGH,KAAK;QAAEhC,SAAS,EAAEiC,MAAM,CAACE;MAAQ,CAAC;IAChD,KAAK,eAAe;MAClB,OAAO;QAAE,GAAGH,KAAK;QAAE/B,QAAQ,EAAEgC,MAAM,CAACE;MAAQ,CAAC;IAC/C,KAAK,oBAAoB;MACvB,OAAO;QAAE,GAAGH,KAAK;QAAEX,aAAa,EAAEY,MAAM,CAACE;MAAQ,CAAC;IACpD,KAAK,sBAAsB;MACzB,OAAO;QAAE,GAAGH,KAAK;QAAE9B,eAAe,EAAE+B,MAAM,CAACE;MAAQ,CAAC;IACtD,KAAK,cAAc;MACjB,MAAMC,YAAY,GAAG,IAAI5B,GAAG,CAACwB,KAAK,CAACzB,SAAS,CAAC;MAC7C6B,YAAY,CAACC,GAAG,CAACJ,MAAM,CAACE,OAAO,CAACG,UAAU,EAAEL,MAAM,CAACE,OAAO,CAAC;MAC3D,OAAO;QAAE,GAAGH,KAAK;QAAEzB,SAAS,EAAE6B;MAAa,CAAC;IAC9C,KAAK,iBAAiB;MACpB,OAAO;QACL,GAAGJ,KAAK;QACRvB,QAAQ,EAAE;UAAE,GAAGuB,KAAK,CAACvB,QAAQ;UAAE,GAAGwB,MAAM,CAACE;QAAQ;MACnD,CAAC;IACH,KAAK,eAAe;MAClB,MAAMI,WAAW,GAAG,IAAI/B,GAAG,CAAC,CAAC;MAC7ByB,MAAM,CAACE,OAAO,CAACK,OAAO,CAACC,QAAQ,IAAI;QACjCF,WAAW,CAACF,GAAG,CAACI,QAAQ,CAACH,UAAU,EAAEG,QAAQ,CAAC;MAChD,CAAC,CAAC;MACF,OAAO;QAAE,GAAGT,KAAK;QAAEzB,SAAS,EAAEgC;MAAY,CAAC;IAC7C,KAAK,gBAAgB;MACnB,OAAO;QAAE,GAAGP,KAAK;QAAEV,SAAS,EAAEW,MAAM,CAACE;MAAQ,CAAC;IAChD,KAAK,oBAAoB;MACvB,OAAO;QAAE,GAAGH,KAAK;QAAET,YAAY,EAAEU,MAAM,CAACE;MAAQ,CAAC;IACnD,KAAK,eAAe;MAClB,OAAO;QAAE,GAAGH,KAAK;QAAER,WAAW,EAAES,MAAM,CAACE;MAAQ,CAAC;IAClD,KAAK,YAAY;MACf,OAAO;QAAE,GAAGpC,YAAY;QAAEsB,aAAa,EAAEW,KAAK,CAACX;MAAc,CAAC;IAChE;IACA,KAAK,oBAAoB;MACvB,OAAO;QACL,GAAGW,KAAK;QACRP,eAAe,EAAEiB,IAAI,CAACC,GAAG,CAAC,CAAC;QAC3BhB,mBAAmB,EAAEK,KAAK,CAACN,eAAe;QAC1CE,eAAe,EAAE,KAAK;QACtBC,gBAAgB,EAAE,KAAK;QACvBC,aAAa,EAAE;MACjB,CAAC;IACH,KAAK,cAAc;MACjB,OAAO;QACL,GAAGE,KAAK;QACRL,mBAAmB,EAAEM,MAAM,CAACE,OAAO,CAACS,aAAa;QACjDhB,eAAe,EAAEK,MAAM,CAACE,OAAO,CAACU,WAAW;QAC3ChB,gBAAgB,EAAEI,MAAM,CAACE,OAAO,CAACW;MACnC,CAAC;IACH,KAAK,eAAe;MAClB,OAAO;QACL,GAAGd,KAAK;QACRF,aAAa,EAAE,IAAI;QACnBH,mBAAmB,EAAE,CAAC;QACtBH,WAAW,EAAE;MACf,CAAC;IACH;MACE,OAAOQ,KAAK;EAChB;AACF;;AAEA;;AA2BA,MAAMe,WAAW,gBAAG9D,aAAa,CAA8B+D,SAAS,CAAC;AAEzE,OAAO,SAASC,YAAYA,CAAC;EAAEC;AAAkC,CAAC,EAAE;EAAAC,EAAA;EAClE,MAAM,CAACnB,KAAK,EAAEoB,QAAQ,CAAC,GAAGjE,UAAU,CAAC4C,WAAW,EAAEhC,YAAY,CAAC;EAC/D,MAAMsD,kBAAkB,GAAG/D,MAAM,CAAC,KAAK,CAAC;EACxC,MAAMgE,gBAAgB,GAAGhE,MAAM,CAAC,KAAK,CAAC;EACtC,MAAM,CAACiE,aAAa,EAAEC,gBAAgB,CAAC,GAAGjE,QAAQ,CAAwC,IAAI,CAAC;EAC/F,MAAMkE,kBAAkB,GAAGnE,MAAM,CAAS,CAAC,CAAC,CAAC,CAAC;;EAG9C;EACAF,SAAS,CAAC,MAAM;IACd,IAAIiE,kBAAkB,CAACK,OAAO,EAAE;IAEhC,MAAMC,QAAQ,GAAG,MAAAA,CAAA,KAAY;MAC3B,IAAI;QACFN,kBAAkB,CAACK,OAAO,GAAG,IAAI;QACjCN,QAAQ,CAAC;UAAElB,IAAI,EAAE,aAAa;UAAEC,OAAO,EAAE;QAAK,CAAC,CAAC;QAChDiB,QAAQ,CAAC;UAAElB,IAAI,EAAE,WAAW;UAAEC,OAAO,EAAE;QAAK,CAAC,CAAC;QAE9CyB,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;QACrD,MAAMC,IAAI,GAAG,MAAMtE,iBAAiB,CAAC,CAAC;QACtCoE,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEC,IAAI,CAACC,MAAM,EAAE,YAAY,CAAC;QAExEX,QAAQ,CAAC;UAAElB,IAAI,EAAE,oBAAoB;UAAEC,OAAO,EAAE2B;QAAK,CAAC,CAAC;QAEvD,MAAM/C,cAAc,GAAGiD,iBAAiB,CAACF,IAAI,CAAC;QAC9CF,OAAO,CAACC,GAAG,CAAC,0CAA0C,EAAE9C,cAAc,CAAC;QAEvEqC,QAAQ,CAAC;UAAElB,IAAI,EAAE,iBAAiB;UAAEC,OAAO,EAAE;YAAEpB;UAAe;QAAE,CAAC,CAAC;MAEpE,CAAC,CAAC,OAAOK,KAAK,EAAE;QACdwC,OAAO,CAACxC,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;QAC7DgC,QAAQ,CAAC;UAAElB,IAAI,EAAE,WAAW;UAAEC,OAAO,EAAE;QAA0D,CAAC,CAAC;QACnGkB,kBAAkB,CAACK,OAAO,GAAG,KAAK;MACpC,CAAC,SAAS;QACRN,QAAQ,CAAC;UAAElB,IAAI,EAAE,aAAa;UAAEC,OAAO,EAAE;QAAM,CAAC,CAAC;MACnD;IACF,CAAC;IAEDwB,QAAQ,CAAC,CAAC;EACZ,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMK,iBAAiB,GAAI3C,aAAyB,IAAa;IAC/D,OAAOA,aAAa,CAAC4C,MAAM,CAAC,CAACC,KAAK,EAAEC,QAAQ,KAAK;MAC/C,OAAOD,KAAK,GAAGC,QAAQ,CAACC,aAAa,CAACH,MAAM,CAAC,CAACI,QAAQ,EAAEC,WAAW,KAAK;QACtE,OAAOD,QAAQ,GAAGC,WAAW,CAACC,MAAM,CAACN,MAAM,CAAC,CAACO,UAAU,EAAEC,KAAK,KAAK;UACjE,OAAOD,UAAU,GAAGC,KAAK,CAACC,SAAS,CAACX,MAAM;QAC5C,CAAC,EAAE,CAAC,CAAC;MACP,CAAC,EAAE,CAAC,CAAC;IACP,CAAC,EAAE,CAAC,CAAC;EACP,CAAC;;EAED;EACA,MAAMY,qBAAqB,GAAGtF,WAAW,CAAC,YAAY;IACpD,IAAI2C,KAAK,CAAChC,SAAS,EAAE;MACnB,IAAI;QACF4D,OAAO,CAACC,GAAG,CAAC,yCAAyC,CAAC;QACtD,MAAMpE,GAAG,CAACmF,YAAY,CAAC5C,KAAK,CAAChC,SAAS,CAAC;QACvCoD,QAAQ,CAAC;UAAElB,IAAI,EAAE,eAAe;UAAEC,OAAO,EAAE;QAAK,CAAC,CAAC;MACpD,CAAC,CAAC,OAAOf,KAAK,EAAE;QACdwC,OAAO,CAACxC,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;MAC/D;IACF;EACF,CAAC,EAAE,CAACY,KAAK,CAAChC,SAAS,CAAC,CAAC;EACrB;EACA,MAAM6E,gBAAgB,GAAGxF,WAAW,CAAC,MAAM;IACzC,MAAMiC,SAAS,GAAGoB,IAAI,CAACC,GAAG,CAAC,CAAC;IAC5BiB,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAE,IAAInB,IAAI,CAACpB,SAAS,CAAC,CAACwD,WAAW,CAAC,CAAC,CAAC;;IAE3E;IACA1B,QAAQ,CAAC;MAAElB,IAAI,EAAE;IAAqB,CAAC,CAAC;IACxCuB,kBAAkB,CAACC,OAAO,GAAGpC,SAAS;;IAEtC;IACA,IAAIiC,aAAa,EAAE;MACjBwB,aAAa,CAACxB,aAAa,CAAC;IAC9B;;IAEA;IACA,MAAMyB,QAAQ,GAAGC,WAAW,CAAC,MAAM;MACjC,MAAMtC,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;MACtB,MAAMuC,OAAO,GAAGvC,GAAG,GAAGc,kBAAkB,CAACC,OAAO,CAAC,CAAC;MAClD,MAAMyB,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEzF,iBAAiB,GAAGsF,OAAO,CAAC;MAE1DtB,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE;QAC3BqB,OAAO,EAAEE,IAAI,CAACE,KAAK,CAACJ,OAAO,GAAG,IAAI,CAAC,GAAG,GAAG;QACzCC,SAAS,EAAEC,IAAI,CAACE,KAAK,CAACH,SAAS,GAAG,IAAI,CAAC,GAAG;MAC5C,CAAC,CAAC;MAEF,MAAMtC,WAAW,GAAGsC,SAAS,IAAItF,sBAAsB,IAAIsF,SAAS,GAAGrF,uBAAuB;MAC9F,MAAMgD,YAAY,GAAGqC,SAAS,IAAIrF,uBAAuB,IAAIqF,SAAS,GAAG,CAAC;MAE1E,IAAIA,SAAS,IAAI,CAAC,EAAE;QAClBvB,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;QAC7BT,QAAQ,CAAC;UAAElB,IAAI,EAAE;QAAgB,CAAC,CAAC;QACnC6C,aAAa,CAACC,QAAQ,CAAC;QACvBxB,gBAAgB,CAAC,IAAI,CAAC;QACtBmB,qBAAqB,CAAC,CAAC;MACzB,CAAC,MAAM;QACLvB,QAAQ,CAAC;UACPlB,IAAI,EAAE,cAAc;UACpBC,OAAO,EAAE;YACPS,aAAa,EAAEuC,SAAS;YACxBtC,WAAW;YACXC;UACF;QACF,CAAC,CAAC;MACJ;IACF,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;;IAEVU,gBAAgB,CAACwB,QAAQ,CAAC;EAC5B,CAAC,EAAE,CAACzB,aAAa,EAAEoB,qBAAqB,CAAC,CAAC;;EAE1C;EACA,MAAMY,iBAAiB,GAAGlG,WAAW,CAAEiC,SAAiB,IAAK;IAC3DsC,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAE,IAAInB,IAAI,CAACpB,SAAS,CAAC,CAACwD,WAAW,CAAC,CAAC,CAAC;IAC7E,MAAMnC,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;IACtB,MAAMuC,OAAO,GAAGvC,GAAG,GAAGrB,SAAS;IAC/B,MAAM6D,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEzF,iBAAiB,GAAGsF,OAAO,CAAC;IAE1DtB,OAAO,CAACC,GAAG,CAAC,eAAe,EAAE;MAC3BvC,SAAS,EAAE,IAAIoB,IAAI,CAACpB,SAAS,CAAC,CAACwD,WAAW,CAAC,CAAC;MAC5CI,OAAO,EAAEE,IAAI,CAACE,KAAK,CAACJ,OAAO,GAAG,IAAI,CAAC,GAAG,GAAG;MACzCC,SAAS,EAAEC,IAAI,CAACE,KAAK,CAACH,SAAS,GAAG,IAAI,CAAC,GAAG;IAC5C,CAAC,CAAC;IAEF,IAAIA,SAAS,IAAI,CAAC,EAAE;MAClBvB,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;MAC/CT,QAAQ,CAAC;QAAElB,IAAI,EAAE;MAAgB,CAAC,CAAC;MACnCyC,qBAAqB,CAAC,CAAC;MACvB;IACF;;IAEA;IACAlB,kBAAkB,CAACC,OAAO,GAAGpC,SAAS;;IAEtC;IACA8B,QAAQ,CAAC;MACPlB,IAAI,EAAE,cAAc;MACpBC,OAAO,EAAE;QACPS,aAAa,EAAEuC,SAAS;QACxBtC,WAAW,EAAEsC,SAAS,IAAItF,sBAAsB;QAChDiD,YAAY,EAAEqC,SAAS,IAAIrF;MAC7B;IACF,CAAC,CAAC;;IAEF;IACA,IAAIyD,aAAa,EAAE;MACjBwB,aAAa,CAACxB,aAAa,CAAC;IAC9B;;IAEA;IACA,MAAMyB,QAAQ,GAAGC,WAAW,CAAC,MAAM;MACjC,MAAMtC,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;MACtB,MAAMuC,OAAO,GAAGvC,GAAG,GAAGc,kBAAkB,CAACC,OAAO,CAAC,CAAC;MAClD,MAAMyB,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEzF,iBAAiB,GAAGsF,OAAO,CAAC;MAE1D,MAAMrC,WAAW,GAAGsC,SAAS,IAAItF,sBAAsB,IAAIsF,SAAS,GAAGrF,uBAAuB;MAC9F,MAAMgD,YAAY,GAAGqC,SAAS,IAAIrF,uBAAuB,IAAIqF,SAAS,GAAG,CAAC;MAE1E,IAAIA,SAAS,IAAI,CAAC,EAAE;QAClB/B,QAAQ,CAAC;UAAElB,IAAI,EAAE;QAAgB,CAAC,CAAC;QACnC6C,aAAa,CAACC,QAAQ,CAAC;QACvBxB,gBAAgB,CAAC,IAAI,CAAC;QACtBmB,qBAAqB,CAAC,CAAC;MACzB,CAAC,MAAM;QACLvB,QAAQ,CAAC;UACPlB,IAAI,EAAE,cAAc;UACpBC,OAAO,EAAE;YACPS,aAAa,EAAEuC,SAAS;YACxBtC,WAAW;YACXC;UACF;QACF,CAAC,CAAC;MACJ;IACF,CAAC,EAAE,IAAI,CAAC;IAERU,gBAAgB,CAACwB,QAAQ,CAAC;EAC5B,CAAC,EAAE,CAACzB,aAAa,EAAEoB,qBAAqB,CAAC,CAAC;;EAE1C;EACAvF,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX,IAAImE,aAAa,EAAE;QACjBwB,aAAa,CAACxB,aAAa,CAAC;MAC9B;IACF,CAAC;EACH,CAAC,EAAE,CAACA,aAAa,CAAC,CAAC;;EAEnB;EACA,MAAMiC,mBAAmB,GAAGnG,WAAW,CAAEoG,YAAoB,IAAa;IACxE,MAAMC,YAAY,GAAGN,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,KAAK,CAACG,YAAY,GAAG,IAAI,CAAC,CAAC;IACjE,MAAME,OAAO,GAAGP,IAAI,CAACE,KAAK,CAACI,YAAY,GAAG,EAAE,CAAC;IAC7C,MAAME,OAAO,GAAGF,YAAY,GAAG,EAAE;IACjC,OAAO,GAAGC,OAAO,IAAIC,OAAO,CAACC,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;EAC5D,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMC,iBAAiB,GAAG1G,WAAW,CAAC,MAAOY,QAAkB,IAAK;IAClE,IAAI;MACFmD,QAAQ,CAAC;QAAElB,IAAI,EAAE,aAAa;QAAEC,OAAO,EAAE;MAAK,CAAC,CAAC;MAChD,MAAMM,QAAQ,GAAG,MAAMhD,GAAG,CAACuG,UAAU,CAAC/F,QAAQ,CAAC;MAC/CmD,QAAQ,CAAC;QAAElB,IAAI,EAAE,gBAAgB;QAAEC,OAAO,EAAEM,QAAQ,CAACzC;MAAU,CAAC,CAAC;MACjEoD,QAAQ,CAAC;QAAElB,IAAI,EAAE,eAAe;QAAEC,OAAO,EAAElC;MAAS,CAAC,CAAC;MAEtD,MAAMqB,SAAS,GAAGoB,IAAI,CAACC,GAAG,CAAC,CAAC;MAC5BS,QAAQ,CAAC;QAAElB,IAAI,EAAE,gBAAgB;QAAEC,OAAO,EAAEb;MAAU,CAAC,CAAC;;MAExD;MACA2E,YAAY,CAACC,OAAO,CAAC,yBAAyB,EAAEzD,QAAQ,CAACzC,SAAS,CAAC;MACnEiG,YAAY,CAACC,OAAO,CAAC,yBAAyB,EAAE5E,SAAS,CAACuE,QAAQ,CAAC,CAAC,CAAC;;MAErE;MACAjC,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;MACvDgB,gBAAgB,CAAC,CAAC;IAEpB,CAAC,CAAC,OAAOzD,KAAK,EAAE;MACdgC,QAAQ,CAAC;QAAElB,IAAI,EAAE,WAAW;QAAEC,OAAO,EAAE;MAAgC,CAAC,CAAC;MACzE,MAAMf,KAAK;IACb,CAAC,SAAS;MACRgC,QAAQ,CAAC;QAAElB,IAAI,EAAE,aAAa;QAAEC,OAAO,EAAE;MAAM,CAAC,CAAC;IACnD;EACF,CAAC,EAAE,CAAC0C,gBAAgB,CAAC,CAAC;EAEtB,MAAMsB,eAAe,GAAG9G,WAAW,CAAC,MAAOW,SAAiB,IAAK;IAC/D,IAAIsD,gBAAgB,CAACI,OAAO,EAAE;IAE9B,IAAI;MACFJ,gBAAgB,CAACI,OAAO,GAAG,IAAI;MAC/BN,QAAQ,CAAC;QAAElB,IAAI,EAAE,aAAa;QAAEC,OAAO,EAAE;MAAK,CAAC,CAAC;MAEhDyB,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;MACnD,MAAMuC,IAAI,GAAG,MAAM3G,GAAG,CAAC4G,OAAO,CAACrG,SAAS,CAAC;MAEzCoD,QAAQ,CAAC;QAAElB,IAAI,EAAE,gBAAgB;QAAEC,OAAO,EAAEnC;MAAU,CAAC,CAAC;MACxDoD,QAAQ,CAAC;QAAElB,IAAI,EAAE,eAAe;QAAEC,OAAO,EAAEiE,IAAI,CAACnG;MAAS,CAAC,CAAC;MAC3DmD,QAAQ,CAAC;QAAElB,IAAI,EAAE,eAAe;QAAEC,OAAO,EAAEiE,IAAI,CAAC5E;MAAY,CAAC,CAAC;;MAE9D;MACAoC,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;MACrD,MAAMtD,SAAS,GAAG,MAAMd,GAAG,CAAC6G,gBAAgB,CAACtG,SAAS,CAAC;MACvD4D,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEtD,SAAS,CAACwD,MAAM,CAAC;MAE/DX,QAAQ,CAAC;QAAElB,IAAI,EAAE,eAAe;QAAEC,OAAO,EAAE5B;MAAU,CAAC,CAAC;;MAEvD;MACA,MAAMQ,cAAc,GAAGiD,iBAAiB,CAAChC,KAAK,CAACX,aAAa,CAAC;MAE7D,MAAMkF,eAAe,GAAG;QACtB,GAAGH,IAAI,CAAC3F,QAAQ;QAChBM,cAAc;QACdD,kBAAkB,EAAEP,SAAS,CAACwD;MAChC,CAAC;MAEDX,QAAQ,CAAC;QAAElB,IAAI,EAAE,iBAAiB;QAAEC,OAAO,EAAEoE;MAAgB,CAAC,CAAC;;MAE/D;MACA,MAAMC,YAAY,GAAGC,0BAA0B,CAAClG,SAAS,EAAEyB,KAAK,CAACX,aAAa,CAAC;MAC/EuC,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAE2C,YAAY,CAAC;MAE9DpD,QAAQ,CAAC;QAAElB,IAAI,EAAE,sBAAsB;QAAEC,OAAO,EAAEqE;MAAa,CAAC,CAAC;;MAEjE;MACA,IAAI,CAACJ,IAAI,CAAC5E,WAAW,EAAE;QACrB,MAAMkF,cAAc,GAAGT,YAAY,CAACU,OAAO,CAAC,yBAAyB,CAAC;QACtE,IAAID,cAAc,EAAE;UAClBnB,iBAAiB,CAACqB,QAAQ,CAACF,cAAc,CAAC,CAAC;QAC7C,CAAC,MAAM;UACL;UACAT,YAAY,CAACC,OAAO,CAAC,yBAAyB,EAAExD,IAAI,CAACC,GAAG,CAAC,CAAC,CAACkD,QAAQ,CAAC,CAAC,CAAC;UACtEhB,gBAAgB,CAAC,CAAC;QACpB;MACF;IAEF,CAAC,CAAC,OAAOzD,KAAK,EAAE;MACdgC,QAAQ,CAAC;QAAElB,IAAI,EAAE,WAAW;QAAEC,OAAO,EAAE;MAA8B,CAAC,CAAC;MACvE,MAAMf,KAAK;IACb,CAAC,SAAS;MACRgC,QAAQ,CAAC;QAAElB,IAAI,EAAE,aAAa;QAAEC,OAAO,EAAE;MAAM,CAAC,CAAC;MACjDmB,gBAAgB,CAACI,OAAO,GAAG,KAAK;IAClC;EACF,CAAC,EAAE,CAAC1B,KAAK,CAACX,aAAa,EAAEkE,iBAAiB,EAAEV,gBAAgB,CAAC,CAAC;EAE9D,MAAM4B,0BAA0B,GAAGpH,WAAW,CAAC,CAACkB,SAA6B,EAAEc,aAAyB,KAAK;IAC3G,MAAMwF,iBAAiB,GAAG,IAAIC,GAAG,CAACvG,SAAS,CAACwG,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC1E,UAAU,CAAC,CAAC;IAEnE,KAAK,IAAInC,aAAa,GAAG,CAAC,EAAEA,aAAa,GAAGkB,aAAa,CAAC0C,MAAM,EAAE5D,aAAa,EAAE,EAAE;MACjF,MAAMgE,QAAQ,GAAG9C,aAAa,CAAClB,aAAa,CAAC;MAE7C,KAAK,IAAIC,gBAAgB,GAAG,CAAC,EAAEA,gBAAgB,GAAG+D,QAAQ,CAACC,aAAa,CAACL,MAAM,EAAE3D,gBAAgB,EAAE,EAAE;QACnG,MAAMkE,WAAW,GAAGH,QAAQ,CAACC,aAAa,CAAChE,gBAAgB,CAAC;QAE5D,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGiE,WAAW,CAACC,MAAM,CAACR,MAAM,EAAE1D,UAAU,EAAE,EAAE;UAC7E,MAAMoE,KAAK,GAAGH,WAAW,CAACC,MAAM,CAAClE,UAAU,CAAC;UAE5C,KAAK,IAAIC,aAAa,GAAG,CAAC,EAAEA,aAAa,GAAGmE,KAAK,CAACC,SAAS,CAACX,MAAM,EAAEzD,aAAa,EAAE,EAAE;YACnF,MAAMgC,UAAU,GAAG,GAAGnC,aAAa,IAAIC,gBAAgB,IAAIC,UAAU,IAAIC,aAAa,EAAE;YAExF,IAAI,CAACuG,iBAAiB,CAACI,GAAG,CAAC3E,UAAU,CAAC,EAAE;cACtC,OAAO;gBACLnC,aAAa;gBACbC,gBAAgB;gBAChBC,UAAU;gBACVC;cACF,CAAC;YACH;UACF;QACF;MACF;IACF;IAEA,IAAIe,aAAa,CAAC0C,MAAM,GAAG,CAAC,EAAE;MAC5B,MAAMmD,YAAY,GAAG7F,aAAa,CAACA,aAAa,CAAC0C,MAAM,GAAG,CAAC,CAAC;MAC5D,MAAMoD,eAAe,GAAGD,YAAY,CAAC9C,aAAa,CAAC8C,YAAY,CAAC9C,aAAa,CAACL,MAAM,GAAG,CAAC,CAAC;MACzF,MAAMqD,SAAS,GAAGD,eAAe,CAAC5C,MAAM,CAAC4C,eAAe,CAAC5C,MAAM,CAACR,MAAM,GAAG,CAAC,CAAC;MAE3E,OAAO;QACL5D,aAAa,EAAEkB,aAAa,CAAC0C,MAAM,GAAG,CAAC;QACvC3D,gBAAgB,EAAE8G,YAAY,CAAC9C,aAAa,CAACL,MAAM,GAAG,CAAC;QACvD1D,UAAU,EAAE8G,eAAe,CAAC5C,MAAM,CAACR,MAAM,GAAG,CAAC;QAC7CzD,aAAa,EAAE8G,SAAS,CAAC1C,SAAS,CAACX,MAAM,GAAG;MAC9C,CAAC;IACH;IAEA,OAAO;MAAE5D,aAAa,EAAE,CAAC;MAAEC,gBAAgB,EAAE,CAAC;MAAEC,UAAU,EAAE,CAAC;MAAEC,aAAa,EAAE;IAAE,CAAC;EACnF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAM+G,YAAY,GAAGhI,WAAW,CAAC,MAAOoD,QAA0B,IAAK;IACrE,IAAI;MACFmB,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEpB,QAAQ,CAAC;MACtD,MAAMhD,GAAG,CAAC4H,YAAY,CAAC5E,QAAQ,CAAC;MAChCW,QAAQ,CAAC;QAAElB,IAAI,EAAE,cAAc;QAAEC,OAAO,EAAEM;MAAS,CAAC,CAAC;MACrDW,QAAQ,CAAC;QAAElB,IAAI,EAAE,oBAAoB;QAAEC,OAAO,EAAEO,IAAI,CAACC,GAAG,CAAC;MAAE,CAAC,CAAC;MAE7D,MAAM2E,aAAa,GAAG,CAACtF,KAAK,CAACzB,SAAS,CAAC0G,GAAG,CAACxE,QAAQ,CAACH,UAAU,CAAC;MAC/D,IAAIgF,aAAa,EAAE;QACjB,MAAMxG,kBAAkB,GAAGkB,KAAK,CAACvB,QAAQ,CAACK,kBAAkB,GAAG,CAAC;QAChEsC,QAAQ,CAAC;UAAElB,IAAI,EAAE,iBAAiB;UAAEC,OAAO,EAAE;YAAErB;UAAmB;QAAE,CAAC,CAAC;MACxE;IAEF,CAAC,CAAC,OAAOM,KAAK,EAAE;MACdwC,OAAO,CAACxC,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC3DgC,QAAQ,CAAC;QAAElB,IAAI,EAAE,WAAW;QAAEC,OAAO,EAAE;MAA0B,CAAC,CAAC;MACnE,MAAMf,KAAK;IACb;EACF,CAAC,EAAE,CAACY,KAAK,CAACzB,SAAS,EAAEyB,KAAK,CAACvB,QAAQ,CAACK,kBAAkB,CAAC,CAAC;EAExD,MAAMyG,kBAAkB,GAAGlI,WAAW,CAAC,OAAOc,aAAqB,EAAEC,gBAAwB,EAAEC,UAAkB,EAAEC,aAAqB,KAAK;IAC3I,MAAMkH,WAAW,GAAG;MAAErH,aAAa;MAAEC,gBAAgB;MAAEC,UAAU;MAAEC;IAAc,CAAC;IAClF8C,QAAQ,CAAC;MAAElB,IAAI,EAAE,sBAAsB;MAAEC,OAAO,EAAEqF;IAAY,CAAC,CAAC;IAEhE,IAAIxF,KAAK,CAAChC,SAAS,EAAE;MACnB,IAAI;QACF,MAAMP,GAAG,CAACgI,kBAAkB,CAACzF,KAAK,CAAChC,SAAS,EAAE;UAC5CU,eAAe,EAAEP,aAAa;UAC9BQ,kBAAkB,EAAEP,gBAAgB;UACpCQ,YAAY,EAAEP,UAAU;UACxBQ,eAAe,EAAEP;QACnB,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOc,KAAK,EAAE;QACdwC,OAAO,CAACxC,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;MAC7D;IACF;EACF,CAAC,EAAE,CAACY,KAAK,CAAChC,SAAS,CAAC,CAAC;EAErB,MAAM0H,sBAAsB,GAAGrI,WAAW,CAAC,MAAM;IAC/C,MAAM;MAAEc,aAAa;MAAEC,gBAAgB;MAAEC,UAAU;MAAEC;IAAc,CAAC,GAAG0B,KAAK,CAAC9B,eAAe;IAE5F,IAAI,CAAC8B,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC,EAAE,OAAO,IAAI;IAEpD,MAAMgE,QAAQ,GAAGnC,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC;IACnD,MAAMmE,WAAW,GAAGH,QAAQ,CAACC,aAAa,CAAChE,gBAAgB,CAAC;IAC5D,MAAMqE,KAAK,GAAGH,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEC,MAAM,CAAClE,UAAU,CAAC;IAC7C,MAAMsH,QAAQ,GAAGlD,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,SAAS,CAACpE,aAAa,CAAC;IAEhD,IAAI,CAACqH,QAAQ,EAAE,OAAO,IAAI;IAE1B,OAAO;MACLxD,QAAQ,EAAEA,QAAQ,CAACA,QAAQ;MAC3BG,WAAW,EAAEA,WAAW,CAACA,WAAW;MACpCG,KAAK,EAAEA,KAAK,CAACA,KAAK;MAClBkD,QAAQ;MACRrF,UAAU,EAAE,GAAGnC,aAAa,IAAIC,gBAAgB,IAAIC,UAAU,IAAIC,aAAa;IACjF,CAAC;EACH,CAAC,EAAE,CAAC0B,KAAK,CAAC9B,eAAe,EAAE8B,KAAK,CAACX,aAAa,CAAC,CAAC;EAEhD,MAAMuG,kBAAkB,GAAGvI,WAAW,CAAC,MAAM;IAC3C,MAAMyE,IAAI,GAAG4D,sBAAsB,CAAC,CAAC;IACrC,OAAO,CAAA5D,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAE6D,QAAQ,KAAI,IAAI;EAC/B,CAAC,EAAE,CAACD,sBAAsB,CAAC,CAAC;EAE5B,MAAMG,cAAc,GAAGxI,WAAW,CAAC,YAAY;IAC7C,MAAM;MAAEc,aAAa;MAAEC,gBAAgB;MAAEC,UAAU;MAAEC;IAAc,CAAC,GAAG0B,KAAK,CAAC9B,eAAe;IAC5F,MAAMiE,QAAQ,GAAGnC,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC;IAEnD,IAAI,CAACgE,QAAQ,EAAE;IAEf,MAAMG,WAAW,GAAGH,QAAQ,CAACC,aAAa,CAAChE,gBAAgB,CAAC;IAC5D,MAAMqE,KAAK,GAAGH,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEC,MAAM,CAAClE,UAAU,CAAC;IAE7C,IAAI,CAACoE,KAAK,EAAE;IAEZ,IAAI+C,WAAW,GAAG;MAAE,GAAGxF,KAAK,CAAC9B;IAAgB,CAAC;IAE9C,IAAII,aAAa,GAAGmE,KAAK,CAACC,SAAS,CAACX,MAAM,GAAG,CAAC,EAAE;MAC9CyD,WAAW,CAAClH,aAAa,GAAGA,aAAa,GAAG,CAAC;IAC/C,CAAC,MAAM,IAAID,UAAU,GAAGiE,WAAW,CAACC,MAAM,CAACR,MAAM,GAAG,CAAC,EAAE;MACrDyD,WAAW,CAACnH,UAAU,GAAGA,UAAU,GAAG,CAAC;MACvCmH,WAAW,CAAClH,aAAa,GAAG,CAAC;IAC/B,CAAC,MAAM,IAAIF,gBAAgB,GAAG+D,QAAQ,CAACC,aAAa,CAACL,MAAM,GAAG,CAAC,EAAE;MAC/DyD,WAAW,CAACpH,gBAAgB,GAAGA,gBAAgB,GAAG,CAAC;MACnDoH,WAAW,CAACnH,UAAU,GAAG,CAAC;MAC1BmH,WAAW,CAAClH,aAAa,GAAG,CAAC;IAC/B,CAAC,MAAM,IAAIH,aAAa,GAAG6B,KAAK,CAACX,aAAa,CAAC0C,MAAM,GAAG,CAAC,EAAE;MACzDyD,WAAW,CAACrH,aAAa,GAAGA,aAAa,GAAG,CAAC;MAC7CqH,WAAW,CAACpH,gBAAgB,GAAG,CAAC;MAChCoH,WAAW,CAACnH,UAAU,GAAG,CAAC;MAC1BmH,WAAW,CAAClH,aAAa,GAAG,CAAC;IAC/B,CAAC,MAAM;MACL8C,QAAQ,CAAC;QAAElB,IAAI,EAAE,eAAe;QAAEC,OAAO,EAAE;MAAK,CAAC,CAAC;MAClD;IACF;IAEAiB,QAAQ,CAAC;MAAElB,IAAI,EAAE,sBAAsB;MAAEC,OAAO,EAAEqF;IAAY,CAAC,CAAC;IAEhE,IAAIxF,KAAK,CAAChC,SAAS,EAAE;MACnB,IAAI;QACF,MAAMP,GAAG,CAACgI,kBAAkB,CAACzF,KAAK,CAAChC,SAAS,EAAE;UAC5CU,eAAe,EAAE8G,WAAW,CAACrH,aAAa;UAC1CQ,kBAAkB,EAAE6G,WAAW,CAACpH,gBAAgB;UAChDQ,YAAY,EAAE4G,WAAW,CAACnH,UAAU;UACpCQ,eAAe,EAAE2G,WAAW,CAAClH;QAC/B,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOc,KAAK,EAAE;QACdwC,OAAO,CAACxC,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD;IACF;EACF,CAAC,EAAE,CAACY,KAAK,CAAC9B,eAAe,EAAE8B,KAAK,CAACX,aAAa,EAAEW,KAAK,CAAChC,SAAS,CAAC,CAAC;EAEjE,MAAM8H,kBAAkB,GAAGzI,WAAW,CAAC,YAAY;IACjD,MAAM;MAAEc,aAAa;MAAEC,gBAAgB;MAAEC,UAAU;MAAEC;IAAc,CAAC,GAAG0B,KAAK,CAAC9B,eAAe;IAE5F,IAAIsH,WAAW,GAAG;MAAE,GAAGxF,KAAK,CAAC9B;IAAgB,CAAC;IAE9C,IAAII,aAAa,GAAG,CAAC,EAAE;MACrBkH,WAAW,CAAClH,aAAa,GAAGA,aAAa,GAAG,CAAC;IAC/C,CAAC,MAAM,IAAID,UAAU,GAAG,CAAC,EAAE;MACzB,MAAM0H,SAAS,GAAG/F,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC,CAACiE,aAAa,CAAChE,gBAAgB,CAAC,CAACmE,MAAM,CAAClE,UAAU,GAAG,CAAC,CAAC;MAC3GmH,WAAW,CAACnH,UAAU,GAAGA,UAAU,GAAG,CAAC;MACvCmH,WAAW,CAAClH,aAAa,GAAGyH,SAAS,CAACrD,SAAS,CAACX,MAAM,GAAG,CAAC;IAC5D,CAAC,MAAM,IAAI3D,gBAAgB,GAAG,CAAC,EAAE;MAC/B,MAAM4H,eAAe,GAAGhG,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC,CAACiE,aAAa,CAAChE,gBAAgB,GAAG,CAAC,CAAC;MAC9F,MAAMgH,SAAS,GAAGY,eAAe,CAACzD,MAAM,CAACyD,eAAe,CAACzD,MAAM,CAACR,MAAM,GAAG,CAAC,CAAC;MAC3EyD,WAAW,CAACpH,gBAAgB,GAAGA,gBAAgB,GAAG,CAAC;MACnDoH,WAAW,CAACnH,UAAU,GAAG2H,eAAe,CAACzD,MAAM,CAACR,MAAM,GAAG,CAAC;MAC1DyD,WAAW,CAAClH,aAAa,GAAG8G,SAAS,CAAC1C,SAAS,CAACX,MAAM,GAAG,CAAC;IAC5D,CAAC,MAAM,IAAI5D,aAAa,GAAG,CAAC,EAAE;MAC5B,MAAM8H,YAAY,GAAGjG,KAAK,CAACX,aAAa,CAAClB,aAAa,GAAG,CAAC,CAAC;MAC3D,MAAMgH,eAAe,GAAGc,YAAY,CAAC7D,aAAa,CAAC6D,YAAY,CAAC7D,aAAa,CAACL,MAAM,GAAG,CAAC,CAAC;MACzF,MAAMqD,SAAS,GAAGD,eAAe,CAAC5C,MAAM,CAAC4C,eAAe,CAAC5C,MAAM,CAACR,MAAM,GAAG,CAAC,CAAC;MAC3EyD,WAAW,CAACrH,aAAa,GAAGA,aAAa,GAAG,CAAC;MAC7CqH,WAAW,CAACpH,gBAAgB,GAAG6H,YAAY,CAAC7D,aAAa,CAACL,MAAM,GAAG,CAAC;MACpEyD,WAAW,CAACnH,UAAU,GAAG8G,eAAe,CAAC5C,MAAM,CAACR,MAAM,GAAG,CAAC;MAC1DyD,WAAW,CAAClH,aAAa,GAAG8G,SAAS,CAAC1C,SAAS,CAACX,MAAM,GAAG,CAAC;IAC5D;IAEAX,QAAQ,CAAC;MAAElB,IAAI,EAAE,sBAAsB;MAAEC,OAAO,EAAEqF;IAAY,CAAC,CAAC;IAEhE,IAAIxF,KAAK,CAAChC,SAAS,EAAE;MACnB,IAAI;QACF,MAAMP,GAAG,CAACgI,kBAAkB,CAACzF,KAAK,CAAChC,SAAS,EAAE;UAC5CU,eAAe,EAAE8G,WAAW,CAACrH,aAAa;UAC1CQ,kBAAkB,EAAE6G,WAAW,CAACpH,gBAAgB;UAChDQ,YAAY,EAAE4G,WAAW,CAACnH,UAAU;UACpCQ,eAAe,EAAE2G,WAAW,CAAClH;QAC/B,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOc,KAAK,EAAE;QACdwC,OAAO,CAACxC,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAClD;IACF;EACF,CAAC,EAAE,CAACY,KAAK,CAAC9B,eAAe,EAAE8B,KAAK,CAACX,aAAa,EAAEW,KAAK,CAAChC,SAAS,CAAC,CAAC;EAEjE,MAAMkI,iBAAiB,GAAG7I,WAAW,CAAC,MAAM;IAC1C,MAAM0B,cAAc,GAAGiB,KAAK,CAACvB,QAAQ,CAACM,cAAc;IACpD,MAAMD,kBAAkB,GAAGkB,KAAK,CAACzB,SAAS,CAAC4H,IAAI;IAC/C,OAAOpH,cAAc,GAAG,CAAC,GAAID,kBAAkB,GAAGC,cAAc,GAAI,GAAG,GAAG,CAAC;EAC7E,CAAC,EAAE,CAACiB,KAAK,CAACvB,QAAQ,CAACM,cAAc,EAAEiB,KAAK,CAACzB,SAAS,CAAC4H,IAAI,CAAC,CAAC;EAEzD,MAAMC,+BAA+B,GAAG/I,WAAW,CAAC,MAAM;IAAA,IAAAgJ,qBAAA,EAAAC,sBAAA;IACxD,MAAM;MAAEnI,aAAa;MAAEC,gBAAgB;MAAEC;IAAW,CAAC,GAAG2B,KAAK,CAAC9B,eAAe;IAC7E,MAAMuE,KAAK,IAAA4D,qBAAA,GAAGrG,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC,cAAAkI,qBAAA,wBAAAC,sBAAA,GAAlCD,qBAAA,CAAoCjE,aAAa,CAAChE,gBAAgB,CAAC,cAAAkI,sBAAA,uBAAnEA,sBAAA,CAAqE/D,MAAM,CAAClE,UAAU,CAAC;IACrG,OAAO,CAAAoE,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,SAAS,CAACX,MAAM,KAAI,CAAC;EACrC,CAAC,EAAE,CAAC/B,KAAK,CAAC9B,eAAe,EAAE8B,KAAK,CAACX,aAAa,CAAC,CAAC;EAEhD,MAAMkH,mCAAmC,GAAGlJ,WAAW,CAAC,MAAM;IAAA,IAAAmJ,sBAAA,EAAAC,sBAAA;IAC5D,MAAM;MAAEtI,aAAa;MAAEC,gBAAgB;MAAEC;IAAW,CAAC,GAAG2B,KAAK,CAAC9B,eAAe;IAC7E,IAAIwI,SAAS,GAAG,CAAC;IAEjB,MAAMjE,KAAK,IAAA+D,sBAAA,GAAGxG,KAAK,CAACX,aAAa,CAAClB,aAAa,CAAC,cAAAqI,sBAAA,wBAAAC,sBAAA,GAAlCD,sBAAA,CAAoCpE,aAAa,CAAChE,gBAAgB,CAAC,cAAAqI,sBAAA,uBAAnEA,sBAAA,CAAqElE,MAAM,CAAClE,UAAU,CAAC;IACrG,IAAI,CAACoE,KAAK,EAAE,OAAO,CAAC;IAEpBA,KAAK,CAACC,SAAS,CAAClC,OAAO,CAAC,CAACmG,CAAC,EAAErI,aAAa,KAAK;MAC5C,MAAMgC,UAAU,GAAG,GAAGnC,aAAa,IAAIC,gBAAgB,IAAIC,UAAU,IAAIC,aAAa,EAAE;MACxF,IAAI0B,KAAK,CAACzB,SAAS,CAAC0G,GAAG,CAAC3E,UAAU,CAAC,EAAE;QACnCoG,SAAS,EAAE;MACb;IACF,CAAC,CAAC;IAEF,OAAOA,SAAS;EAClB,CAAC,EAAE,CAAC1G,KAAK,CAAC9B,eAAe,EAAE8B,KAAK,CAACX,aAAa,EAAEW,KAAK,CAACzB,SAAS,CAAC,CAAC;;EAEjE;EACA,MAAMqI,YAAY,GAAGvJ,WAAW,CAAC,MAAM;IACrC4G,YAAY,CAAC4C,UAAU,CAAC,yBAAyB,CAAC;IAClD5C,YAAY,CAAC4C,UAAU,CAAC,yBAAyB,CAAC;IAClD,IAAItF,aAAa,EAAE;MACjBwB,aAAa,CAACxB,aAAa,CAAC;MAC5BC,gBAAgB,CAAC,IAAI,CAAC;IACxB;IACAC,kBAAkB,CAACC,OAAO,GAAG,CAAC,CAAC,CAAC;IAChCN,QAAQ,CAAC;MAAElB,IAAI,EAAE;IAAa,CAAC,CAAC;EAClC,CAAC,EAAE,CAACqB,aAAa,CAAC,CAAC;EAEnB,MAAMuF,KAAsB,GAAG;IAC7B9G,KAAK;IACLoB,QAAQ;IACR2C,iBAAiB;IACjBsB,YAAY;IACZQ,cAAc;IACdC,kBAAkB;IAClBI,iBAAiB;IACjBN,kBAAkB;IAClBF,sBAAsB;IACtBU,+BAA+B;IAC/BG,mCAAmC;IACnCpC,eAAe;IACfoB,kBAAkB;IAClBqB,YAAY;IACZ/D,gBAAgB;IAChBW;EACF,CAAC;EAED,oBACE7F,OAAA,CAACoD,WAAW,CAACgG,QAAQ;IAACD,KAAK,EAAEA,KAAM;IAAA5F,QAAA,EAChCA;EAAQ;IAAA8F,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACW,CAAC;AAE3B;AAAChG,EAAA,CAniBeF,YAAY;AAAAmG,EAAA,GAAZnG,YAAY;AAqiB5B,OAAO,SAASoG,OAAOA,CAAA,EAAG;EAAAC,GAAA;EACxB,MAAMC,OAAO,GAAGrK,UAAU,CAAC6D,WAAW,CAAC;EACvC,IAAIwG,OAAO,KAAKvG,SAAS,EAAE;IACzB,MAAM,IAAIwG,KAAK,CAAC,4CAA4C,CAAC;EAC/D;EACA,OAAOD,OAAO;AAChB;AAACD,GAAA,CANeD,OAAO;AAAA,IAAAD,EAAA;AAAAK,YAAA,CAAAL,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}